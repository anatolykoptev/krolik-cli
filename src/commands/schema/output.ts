/**
 * @module commands/schema/output
 * @description Schema output formatters (text, json, markdown)
 */

import type { Logger } from '../../types';
import type { PrismaModel, PrismaEnum } from './parser';
import { groupByFile, groupByDomain } from './grouping';

/**
 * Schema result type
 */
export interface SchemaOutput {
  models: PrismaModel[];
  enums: PrismaEnum[];
  modelCount: number;
  enumCount: number;
}

/**
 * Print schema to console
 */
export function printSchema(
  data: SchemaOutput,
  logger: Logger,
  groupBy: 'file' | 'domain' = 'file',
): void {
  logger.section('Prisma Schema');
  logger.info(`Found ${data.modelCount} models, ${data.enumCount} enums\n`);

  const grouped = groupBy === 'domain' ? groupByDomain(data.models) : groupByFile(data.models);

  for (const [group, models] of grouped) {
    console.log(`\x1b[36m${group}\x1b[0m`);
    for (const model of models) {
      const relInfo = model.relations.length > 0 ? ` \x1b[2mâ†’ ${model.relations.join(', ')}\x1b[0m` : '';
      console.log(`  \x1b[32m${model.name}\x1b[0m (${model.fields.length} fields)${relInfo}`);
    }
    console.log('');
  }

  if (data.enums.length > 0) {
    logger.section('Enums');
    for (const e of data.enums) {
      const preview = e.values.slice(0, 5).join(', ');
      const more = e.values.length > 5 ? '...' : '';
      console.log(`  \x1b[33m${e.name}\x1b[0m: ${preview}${more}`);
    }
    console.log('');
  }
}

/**
 * Format schema as JSON
 */
export function formatJson(data: SchemaOutput): string {
  return JSON.stringify(data, null, 2);
}

/**
 * Format schema as AI-friendly XML
 */
export function formatAI(data: SchemaOutput): string {
  const lines: string[] = [];

  lines.push('<prisma-schema>');
  lines.push(`  <stats models="${data.modelCount}" enums="${data.enumCount}" />`);
  lines.push('');

  const byDomain = groupByDomain(data.models);

  for (const [domain, models] of byDomain) {
    lines.push(`  <domain name="${domain}">`);
    for (const model of models) {
      lines.push(`    <model name="${model.name}" fields="${model.fields.length}">`);
      if (model.relations.length > 0) {
        lines.push(`      <relations>${model.relations.join(', ')}</relations>`);
      }
      lines.push(`      <fields>`);
      for (const field of model.fields) {
        const attrs: string[] = [];
        if (field.isId) attrs.push('pk');
        if (field.isUnique) attrs.push('unique');
        if (!field.isRequired) attrs.push('optional');
        if (field.isArray) attrs.push('array');
        const attrStr = attrs.length > 0 ? ` attrs="${attrs.join(',')}"` : '';
        const defaultStr = field.default ? ` default="${field.default}"` : '';
        lines.push(`        <field name="${field.name}" type="${field.type}"${attrStr}${defaultStr} />`);
      }
      lines.push('      </fields>');
      lines.push('    </model>');
    }
    lines.push('  </domain>');
    lines.push('');
  }

  if (data.enums.length > 0) {
    lines.push('  <enums>');
    for (const e of data.enums) {
      lines.push(`    <enum name="${e.name}">${e.values.join(', ')}</enum>`);
    }
    lines.push('  </enums>');
  }

  lines.push('</prisma-schema>');

  return lines.join('\n');
}

/**
 * Generate markdown documentation
 */
export function formatMarkdown(data: SchemaOutput): string {
  const lines: string[] = [
    '# Database Schema',
    '',
    `> Auto-generated: ${new Date().toISOString().split('T')[0]}`,
    '',
    `**Models:** ${data.modelCount} | **Enums:** ${data.enumCount}`,
    '',
    '---',
    '',
  ];

  const byDomain = groupByDomain(data.models);

  for (const [domain, models] of byDomain) {
    lines.push(`## ${domain}`);
    lines.push('');

    for (const model of models) {
      lines.push(`### ${model.name}`);
      lines.push('');

      if (model.relations.length > 0) {
        lines.push(`**Relations:** ${model.relations.join(', ')}`);
        lines.push('');
      }

      lines.push('| Field | Type | Required | Notes |');
      lines.push('|-------|------|----------|-------|');

      for (const field of model.fields) {
        const notes: string[] = [];
        if (field.isId) notes.push('PK');
        if (field.isUnique) notes.push('Unique');
        if (field.default) notes.push(`Default: ${field.default}`);

        const typeStr = `${field.type}${field.isArray ? '[]' : ''}`;
        lines.push(`| ${field.name} | ${typeStr} | ${field.isRequired ? 'Yes' : 'No'} | ${notes.join(', ')} |`);
      }

      lines.push('');
    }
  }

  if (data.enums.length > 0) {
    lines.push('## Enums');
    lines.push('');

    for (const e of data.enums) {
      lines.push(`### ${e.name}`);
      lines.push('');
      lines.push('```');
      lines.push(e.values.join('\n'));
      lines.push('```');
      lines.push('');
    }
  }

  lines.push('---');
  lines.push('');
  lines.push('*Generated by krolik-cli*');

  return lines.join('\n');
}
