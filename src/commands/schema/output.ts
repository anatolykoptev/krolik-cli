/**
 * @module commands/schema/output
 * @description Schema output formatters (text, json, markdown)
 */

import type { Logger } from '../../types';
import type { PrismaModel, PrismaEnum } from './parser';
import { groupByFile, groupByDomain } from './grouping';

/**
 * Schema result type
 */
export interface SchemaOutput {
  models: PrismaModel[];
  enums: PrismaEnum[];
  modelCount: number;
  enumCount: number;
}

/**
 * Print schema to console
 */
export function printSchema(
  data: SchemaOutput,
  logger: Logger,
  groupBy: 'file' | 'domain' = 'file',
): void {
  logger.section('Prisma Schema');
  logger.info(`Found ${data.modelCount} models, ${data.enumCount} enums\n`);

  const grouped = groupBy === 'domain' ? groupByDomain(data.models) : groupByFile(data.models);

  for (const [group, models] of grouped) {
    console.log(`\x1b[36m${group}\x1b[0m`);
    for (const model of models) {
      const relInfo = model.relations.length > 0 ? ` \x1b[2mâ†’ ${model.relations.join(', ')}\x1b[0m` : '';
      console.log(`  \x1b[32m${model.name}\x1b[0m (${model.fields.length} fields)${relInfo}`);
    }
    console.log('');
  }

  if (data.enums.length > 0) {
    logger.section('Enums');
    for (const e of data.enums) {
      const preview = e.values.slice(0, 5).join(', ');
      const more = e.values.length > 5 ? '...' : '';
      console.log(`  \x1b[33m${e.name}\x1b[0m: ${preview}${more}`);
    }
    console.log('');
  }
}

/**
 * Format schema as JSON
 */
export function formatJson(data: SchemaOutput): string {
  return JSON.stringify(data, null, 2);
}

/**
 * Generate markdown documentation
 */
export function formatMarkdown(data: SchemaOutput): string {
  const lines: string[] = [
    '# Database Schema',
    '',
    `> Auto-generated: ${new Date().toISOString().split('T')[0]}`,
    '',
    `**Models:** ${data.modelCount} | **Enums:** ${data.enumCount}`,
    '',
    '---',
    '',
  ];

  const byDomain = groupByDomain(data.models);

  for (const [domain, models] of byDomain) {
    lines.push(`## ${domain}`);
    lines.push('');

    for (const model of models) {
      lines.push(`### ${model.name}`);
      lines.push('');

      if (model.relations.length > 0) {
        lines.push(`**Relations:** ${model.relations.join(', ')}`);
        lines.push('');
      }

      lines.push('| Field | Type | Required | Notes |');
      lines.push('|-------|------|----------|-------|');

      for (const field of model.fields) {
        const notes: string[] = [];
        if (field.isId) notes.push('PK');
        if (field.isUnique) notes.push('Unique');
        if (field.default) notes.push(`Default: ${field.default}`);

        const typeStr = `${field.type}${field.isArray ? '[]' : ''}`;
        lines.push(`| ${field.name} | ${typeStr} | ${field.isRequired ? 'Yes' : 'No'} | ${notes.join(', ')} |`);
      }

      lines.push('');
    }
  }

  if (data.enums.length > 0) {
    lines.push('## Enums');
    lines.push('');

    for (const e of data.enums) {
      lines.push(`### ${e.name}`);
      lines.push('');
      lines.push('```');
      lines.push(e.values.join('\n'));
      lines.push('```');
      lines.push('');
    }
  }

  lines.push('---');
  lines.push('');
  lines.push('*Generated by krolik-cli*');

  return lines.join('\n');
}
