/**
 * @module commands/routes/output
 * @description Routes output formatters
 */

import type { Logger } from '../../types';
import type { TrpcRouter } from './parser';

/**
 * Routes analysis result
 */
export interface RoutesOutput {
  routers: TrpcRouter[];
  totalProcedures: number;
  queries: number;
  mutations: number;
  protectedCount: number;
}

const MAX_LENGTH = 8;

const SLICE_ARG1_VALUE = MAX_LENGTH;

/**
 * Calculate statistics from routers
 */
export function calculateStats(routers: TrpcRouter[]): RoutesOutput {
  let totalProcedures = 0;
  let queries = 0;
  let mutations = 0;
  let protectedCount = 0;

  for (const router of routers) {
    totalProcedures += router.procedures.length;
    for (const proc of router.procedures) {
      if (proc.type === 'query') queries++;
      if (proc.type === 'mutation') mutations++;
      if (proc.isProtected) protectedCount++;
    }
  }

  return { routers, totalProcedures, queries, mutations, protectedCount };
}

/**
 * Print routes to console
 */
export function printRoutes(data: RoutesOutput, logger: Logger): void {
  logger.section('tRPC Routes');
  logger.info(`Found ${data.routers.length} routers with ${data.totalProcedures} procedures\n`);
  console.log(
    `  Queries: ${data.queries} | Mutations: ${data.mutations} | Protected: ${data.protectedCount}\n`,
  );

  for (const router of data.routers) {
    const procList = router.procedures
      .slice(0, SLICE_ARG1_VALUE)
      .map((p) => {
        const icon = p.type === 'query' ? 'Q' : p.type === 'mutation' ? 'M' : 'S';
        const prot = p.isProtected ? '*' : '';
        return `${icon}:${p.name}${prot}`;
      })
      .join(', ');

    const more =
      router.procedures.length > SLICE_ARG1_VALUE
        ? ` +${router.procedures.length - MAX_LENGTH} more`
        : '';

    console.log(`\x1b[36m${router.file}\x1b[0m (${router.procedures.length})`);
    console.log(`  \x1b[2m${procList}${more}\x1b[0m`);
    console.log('');
  }

  console.log('\x1b[2mLegend: Q=query, M=mutation, S=subscription, *=protected\x1b[0m\n');
}

/**
 * Format routes as JSON
 */
export function formatJson(data: RoutesOutput): string {
  return JSON.stringify(data, null, 2);
}

/**
 * Format routes as AI-friendly XML
 */
export function formatAI(data: RoutesOutput): string {
  const lines: string[] = [];

  lines.push('<trpc-routes>');
  lines.push(
    `  <stats routers="${data.routers.length}" procedures="${data.totalProcedures}" queries="${data.queries}" mutations="${data.mutations}" protected="${data.protectedCount}" />`,
  );
  lines.push('');

  const grouped = groupByDomain(data.routers);

  for (const [domain, routers] of Object.entries(grouped)) {
    if (routers.length === 0) continue;

    lines.push(`  <domain name="${domain}">`);
    for (const router of routers) {
      lines.push(`    <router file="${router.file}" procedures="${router.procedures.length}">`);
      for (const proc of router.procedures) {
        const protAttr = proc.isProtected ? ' protected="true"' : '';
        const inputAttr = proc.hasInput ? ' has_input="true"' : '';
        lines.push(
          `      <procedure name="${proc.name}" type="${proc.type}"${protAttr}${inputAttr} />`,
        );
      }
      lines.push('    </router>');
    }
    lines.push('  </domain>');
    lines.push('');
  }

  lines.push('</trpc-routes>');

  return lines.join('\n');
}

/**
 * Format routes as markdown
 */
export function formatMarkdown(data: RoutesOutput): string {
  const lines: string[] = [
    '# API Routes (tRPC)',
    '',
    `> Auto-generated: ${new Date().toISOString().split('T')[0]}`,
    '',
    `**Routers:** ${data.routers.length} | **Procedures:** ${data.totalProcedures}`,
    `**Queries:** ${data.queries} | **Mutations:** ${data.mutations} | **Protected:** ${data.protectedCount}`,
    '',
    '---',
    '',
  ];

  // Group by domain
  const grouped = groupByDomain(data.routers);

  for (const [domain, routers] of Object.entries(grouped)) {
    if (routers.length === 0) continue;

    lines.push(`## ${domain}`);
    lines.push('');

    for (const router of routers) {
      lines.push(`### ${router.file}`);
      if (router.description) {
        lines.push(`> ${router.description}`);
      }
      lines.push('');

      lines.push('| Procedure | Type | Protected | Input |');
      lines.push('|-----------|------|-----------|-------|');

      for (const proc of router.procedures) {
        lines.push(
          `| ${proc.name} | ${proc.type} | ${proc.isProtected ? 'Yes' : 'No'} | ${proc.hasInput ? 'Yes' : 'No'} |`,
        );
      }

      lines.push('');
    }
  }

  lines.push('---');
  lines.push('');
  lines.push('*Generated by krolik-cli*');

  return lines.join('\n');
}

/**
 * Group routers by domain
 */
function groupByDomain(routers: TrpcRouter[]): Record<string, TrpcRouter[]> {
  const domains: Record<string, TrpcRouter[]> = {
    Business: [],
    User: [],
    Content: [],
    Social: [],
    System: [],
  };

  for (const router of routers) {
    if (router.file.startsWith('business')) {
      domains.Business?.push(router);
    } else if (
      ['user', 'favorites', 'userLists', 'userTodos'].some((k) => router.file.includes(k))
    ) {
      domains.User?.push(router);
    } else if (['places', 'events', 'reviews', 'search'].some((k) => router.file.includes(k))) {
      domains.Content?.push(router);
    } else if (
      ['social', 'activity', 'referral', 'interactions'].some((k) => router.file.includes(k))
    ) {
      domains.Social?.push(router);
    } else {
      domains.System?.push(router);
    }
  }

  return domains;
}
