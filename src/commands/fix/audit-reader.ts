/**
 * @module commands/fix/audit-reader
 * @description Read cached audit data for --from-audit integration
 *
 * This module reads the JSON file generated by `krolik audit`
 * and converts it to QualityIssue[] for the fix command.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import type { QualityIssue, QualitySeverity } from './types';
import type { AIReport, EnrichedIssue, PriorityLevel } from './reporter/types';

// ============================================================================
// CONSTANTS
// ============================================================================

const AUDIT_DATA_FILE = '.krolik/audit-data.json';

// ============================================================================
// TYPES
// ============================================================================

export type AuditDataResult =
  | {
      success: true;
      issues: QualityIssue[];
      report: AIReport;
      age: number; // milliseconds since generation
    }
  | {
      success: false;
      error: string;
    };

// ============================================================================
// PRIORITY TO SEVERITY MAPPING
// ============================================================================

/**
 * Map AIReport priority to QualityIssue severity
 */
function priorityToSeverity(priority: PriorityLevel): QualitySeverity {
  switch (priority) {
    case 'critical':
    case 'high':
      return 'error';
    case 'medium':
      return 'warning';
    case 'low':
      return 'info';
    default:
      return 'warning';
  }
}

// ============================================================================
// ENRICHED ISSUE TO QUALITY ISSUE
// ============================================================================

/**
 * Convert EnrichedIssue to QualityIssue
 */
function enrichedToQualityIssue(enriched: EnrichedIssue): QualityIssue {
  const { issue, priority, fixSuggestion } = enriched;

  // Build result with conditionally included optional properties
  const result: QualityIssue = {
    file: issue.file,
    severity: priorityToSeverity(priority),
    category: issue.category,
    message: issue.message,
  };

  // Only add optional properties if they have values
  if (issue.line !== undefined) result.line = issue.line;
  if (issue.snippet) result.snippet = issue.snippet;
  if (issue.fixerId) result.fixerId = issue.fixerId;

  // Add suggestion if available
  const suggestion = fixSuggestion ?? issue.suggestion;
  if (suggestion) result.suggestion = suggestion;

  return result;
}

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Check if audit data exists
 */
export function hasAuditData(projectRoot: string): boolean {
  const auditPath = path.join(projectRoot, AUDIT_DATA_FILE);
  return fs.existsSync(auditPath);
}

/**
 * Get age of audit data in milliseconds
 */
export function getAuditDataAge(projectRoot: string): number | null {
  const auditPath = path.join(projectRoot, AUDIT_DATA_FILE);
  if (!fs.existsSync(auditPath)) return null;

  try {
    const content = fs.readFileSync(auditPath, 'utf-8');
    const report = JSON.parse(content) as AIReport;
    const generatedAt = new Date(report.meta.generatedAt).getTime();
    return Date.now() - generatedAt;
  } catch {
    return null;
  }
}

/**
 * Read audit data and convert to QualityIssue[]
 *
 * @param projectRoot - Project root directory
 * @param quickWinsOnly - If true, only return quick wins (auto-fixable issues)
 */
export function readAuditData(
  projectRoot: string,
  quickWinsOnly = false,
): AuditDataResult {
  const auditPath = path.join(projectRoot, AUDIT_DATA_FILE);

  // Check if file exists
  if (!fs.existsSync(auditPath)) {
    return {
      success: false,
      error: `No audit data found. Run 'krolik audit' first to generate .krolik/audit-data.json`,
    };
  }

  try {
    const content = fs.readFileSync(auditPath, 'utf-8');
    const report = JSON.parse(content) as AIReport;

    // Calculate age
    const generatedAt = new Date(report.meta.generatedAt).getTime();
    const age = Date.now() - generatedAt;

    // Extract issues based on mode
    let enrichedIssues: EnrichedIssue[];

    if (quickWinsOnly) {
      // Only quick wins (auto-fixable issues)
      enrichedIssues = report.quickWins;
    } else {
      // All issues from all groups
      enrichedIssues = report.groups.flatMap(group => group.issues);
    }

    // Convert to QualityIssue[]
    const issues = enrichedIssues.map(enrichedToQualityIssue);

    return {
      success: true,
      issues,
      report,
      age,
    };
  } catch (error) {
    return {
      success: false,
      error: `Failed to parse audit data: ${error instanceof Error ? error.message : String(error)}`,
    };
  }
}

/**
 * Format age for display
 */
export function formatAuditAge(age: number): string {
  const seconds = Math.floor(age / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  if (days > 0) return `${days}d ago`;
  if (hours > 0) return `${hours}h ago`;
  if (minutes > 0) return `${minutes}m ago`;
  return 'just now';
}

/**
 * Check if audit data is stale (older than threshold)
 *
 * @param projectRoot - Project root directory
 * @param maxAgeMinutes - Maximum age in minutes (default: 60)
 */
export function isAuditDataStale(projectRoot: string, maxAgeMinutes = 60): boolean {
  const age = getAuditDataAge(projectRoot);
  if (age === null) return true;
  return age > maxAgeMinutes * 60 * 1000;
}
