/**
 * @module commands/fix/refactor-reader
 * @description Read cached refactor data for --from-refactor integration
 *
 * This module reads the JSON file generated by `krolik refactor`
 * and converts Recommendations to QualityIssue[] for the fix command.
 *
 * Follows the same pattern as audit-reader.ts for consistency.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import type { EnhancedRefactorAnalysis, Recommendation } from '../refactor/core/types-ai';
import type { QualityIssue } from './core';
import { adaptRecommendationsToIssues } from './recommendation-adapter';

// ============================================================================
// CONSTANTS
// ============================================================================

const REFACTOR_DATA_FILE = '.krolik/refactor-data.json';

// ============================================================================
// TYPES
// ============================================================================

/**
 * Cached refactor data structure
 */
export interface RefactorDataCache {
  timestamp: string;
  path: string;
  recommendations: Recommendation[];
  /** Full analysis for context (optional) */
  analysis?: Partial<EnhancedRefactorAnalysis>;
}

export type RefactorDataResult =
  | {
      success: true;
      issues: QualityIssue[];
      recommendations: Recommendation[];
      cache: RefactorDataCache;
      age: number; // milliseconds since generation
    }
  | {
      success: false;
      error: string;
    };

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Check if refactor data exists
 */
export function hasRefactorData(projectRoot: string): boolean {
  const refactorPath = path.join(projectRoot, REFACTOR_DATA_FILE);
  return fs.existsSync(refactorPath);
}

/**
 * Get age of refactor data in milliseconds
 */
export function getRefactorDataAge(projectRoot: string): number | null {
  const refactorPath = path.join(projectRoot, REFACTOR_DATA_FILE);
  if (!fs.existsSync(refactorPath)) return null;

  try {
    const content = fs.readFileSync(refactorPath, 'utf-8');
    const cache = JSON.parse(content) as RefactorDataCache;
    const generatedAt = new Date(cache.timestamp).getTime();
    return Date.now() - generatedAt;
  } catch {
    return null;
  }
}

/**
 * Read refactor data and convert to QualityIssue[]
 *
 * @param projectRoot - Project root directory
 * @param autoFixableOnly - If true, only return auto-fixable recommendations (default: true)
 */
export function readRefactorData(projectRoot: string, autoFixableOnly = true): RefactorDataResult {
  const refactorPath = path.join(projectRoot, REFACTOR_DATA_FILE);

  // Check if file exists
  if (!fs.existsSync(refactorPath)) {
    return {
      success: false,
      error: `No refactor data found. Run 'krolik refactor' first to generate .krolik/refactor-data.json`,
    };
  }

  try {
    const content = fs.readFileSync(refactorPath, 'utf-8');
    const cache = JSON.parse(content) as RefactorDataCache;

    // Calculate age
    const generatedAt = new Date(cache.timestamp).getTime();
    const age = Date.now() - generatedAt;

    // Filter recommendations
    const recommendations = autoFixableOnly
      ? cache.recommendations.filter((r) => r.autoFixable)
      : cache.recommendations;

    // Convert to QualityIssue[] using adapter
    const issues = adaptRecommendationsToIssues(recommendations);

    return {
      success: true,
      issues,
      recommendations,
      cache,
      age,
    };
  } catch (error) {
    return {
      success: false,
      error: `Failed to parse refactor data: ${error instanceof Error ? error.message : String(error)}`,
    };
  }
}

/**
 * Format age for display
 */
export function formatRefactorAge(age: number): string {
  const seconds = Math.floor(age / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  if (days > 0) return `${days}d ago`;
  if (hours > 0) return `${hours}h ago`;
  if (minutes > 0) return `${minutes}m ago`;
  return 'just now';
}

/**
 * Check if refactor data is stale (older than threshold)
 *
 * @param projectRoot - Project root directory
 * @param maxAgeMinutes - Maximum age in minutes (default: 60)
 */
export function isRefactorDataStale(projectRoot: string, maxAgeMinutes = 60): boolean {
  const age = getRefactorDataAge(projectRoot);
  if (age === null) return true;
  return age > maxAgeMinutes * 60 * 1000;
}

/**
 * Get path to refactor data file
 */
export function getRefactorDataPath(projectRoot: string): string {
  return path.join(projectRoot, REFACTOR_DATA_FILE);
}
