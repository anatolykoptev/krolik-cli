/**
 * @module commands/fix/reporter/formatter
 * @description Formatters for AI Report output
 */

import { escapeXml } from '../../../lib/@format';
import { normalizePath } from './grouping';
import type {
  ActionStep,
  AIReport,
  EnrichedIssue,
  FileContext,
  IssueGroup,
  PriorityLevel,
} from './types';

// ============================================================================
// MARKDOWN FORMATTER
// ============================================================================

/**
 * Format AI Report as Markdown
 */
export function formatAsMarkdown(report: AIReport): string {
  const lines: string[] = [];

  // Header
  lines.push('# AI Code Quality Report');
  lines.push('');
  lines.push(`> Generated by krolik-cli at ${report.meta.generatedAt}`);
  lines.push('');

  // Summary
  lines.push('## Summary');
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Total Issues | ${report.summary.totalIssues} |`);
  lines.push(`| Auto-fixable | ${report.summary.autoFixableIssues} |`);
  lines.push(`| Manual Required | ${report.summary.manualIssues} |`);
  lines.push(`| Total Effort | ${report.summary.totalEffortLabel} |`);
  lines.push('');

  // Priority breakdown
  lines.push('### By Priority');
  lines.push('');
  const priorities: PriorityLevel[] = ['critical', 'high', 'medium', 'low'];
  for (const priority of priorities) {
    const count = report.summary.byPriority[priority];
    if (count > 0) {
      const icon = getPriorityIcon(priority);
      lines.push(`- ${icon} **${priority.toUpperCase()}**: ${count} issues`);
    }
  }
  lines.push('');

  // Context
  if (report.context.techStack && report.context.techStack.length > 0) {
    lines.push('### Tech Stack');
    lines.push('');
    lines.push(report.context.techStack.join(', '));
    lines.push('');
  }

  // AI Rules (CRITICAL - must read first!)
  if (report.aiRules && report.aiRules.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## ‚ö†Ô∏è AI Rules (Read First!)');
    lines.push('');
    lines.push(
      '> **IMPORTANT:** Before starting any work, read these files for project-specific rules and conventions.',
    );
    lines.push('');
    for (const rule of report.aiRules) {
      lines.push(`- \`${rule.path}\` (${rule.scope})`);
    }
    lines.push('');
  }

  // Git Status
  if (report.git) {
    lines.push('---');
    lines.push('');
    lines.push('## Git Status');
    lines.push('');
    lines.push(`- **Branch:** \`${report.git.branch}\``);
    lines.push(
      `- **Changes:** ${report.git.modified} modified, ${report.git.untracked} untracked, ${report.git.staged} staged`,
    );
    lines.push('');
    if (report.git.recentCommits.length > 0) {
      lines.push('### Recent Commits');
      lines.push('');
      for (const commit of report.git.recentCommits.slice(0, 3)) {
        lines.push(`- \`${commit.hash}\` ${commit.message} *(${commit.relativeDate})*`);
      }
      lines.push('');
    }
  }

  // Next Action
  if (report.nextAction) {
    lines.push('---');
    lines.push('');
    lines.push('## üéØ Next Action');
    lines.push('');
    const priorityIcon =
      report.nextAction.priority === 'critical'
        ? 'üî¥'
        : report.nextAction.priority === 'high'
          ? 'üü†'
          : report.nextAction.priority === 'medium'
            ? 'üü°'
            : 'üü¢';
    lines.push(`**${priorityIcon} ${report.nextAction.action}**`);
    if (report.nextAction.reason) {
      lines.push('');
      lines.push(`> ${report.nextAction.reason}`);
    }
    lines.push('');
  }

  // Do-Not Rules
  if (report.doNot && report.doNot.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## üö´ Do Not');
    lines.push('');
    for (const rule of report.doNot) {
      lines.push(`- ${rule}`);
    }
    lines.push('');
  }

  // Quick Wins
  if (report.quickWins.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Quick Wins');
    lines.push('');
    lines.push('These issues can be auto-fixed in seconds:');
    lines.push('');

    for (const win of report.quickWins) {
      const loc = win.issue.line ? `:${win.issue.line}` : '';
      lines.push(
        `- [ ] \`${win.issue.file}${loc}\` ‚Äî ${win.issue.message} (${win.effort.timeLabel})`,
      );
    }
    lines.push('');
  }

  // Hotspots
  if (report.hotspots.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Hotspot Files');
    lines.push('');
    lines.push('Files with the most issues:');
    lines.push('');
    lines.push('| File | Issues | Priority |');
    lines.push('|------|--------|----------|');

    for (const hotspot of report.hotspots.slice(0, 5)) {
      const icon = getPriorityIcon(hotspot.priority);
      lines.push(`| \`${hotspot.file}\` | ${hotspot.issueCount} | ${icon} ${hotspot.priority} |`);
    }
    lines.push('');
  }

  // Issue Groups
  lines.push('---');
  lines.push('');
  lines.push('## Issues by Priority');
  lines.push('');

  for (const group of report.groups) {
    lines.push(...formatGroup(group));
  }

  // Action Plan
  if (report.actionPlan.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Recommended Action Plan');
    lines.push('');
    lines.push('Execute these steps in order:');
    lines.push('');

    for (const step of report.actionPlan.slice(0, 5)) {
      lines.push(...formatActionStep(step));
    }
  }

  // File Contexts (only files with issues, top 15)
  if (report.fileContexts && report.fileContexts.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## File Contexts');
    lines.push('');
    lines.push('Detailed information about affected files:');
    lines.push('');

    for (const ctx of report.fileContexts) {
      lines.push(...formatFileContext(ctx));
    }
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*Use `krolik fix --ai-execute AI-REPORT.md` to execute this plan automatically.*');
  lines.push('');

  return lines.join('\n');
}

/**
 * Format a single file context
 */
function formatFileContext(ctx: FileContext): string[] {
  const lines: string[] = [];

  lines.push(`### \`${ctx.path}\``);
  lines.push('');
  lines.push(`- **Purpose**: ${ctx.purpose}`);
  lines.push(`- **Type**: ${ctx.type}`);
  lines.push(
    `- **Metrics**: ${ctx.metrics.lines} lines, ${ctx.metrics.functions} functions, avg complexity ${ctx.metrics.avgComplexity}`,
  );
  lines.push('');

  if (ctx.exports.length > 0) {
    lines.push(`**Exports**: \`${ctx.exports.join('`, `')}\``);
    lines.push('');
  }

  if (ctx.imports.length > 0) {
    lines.push(`**Imports**: ${ctx.imports.map((i) => `\`${i}\``).join(', ')}`);
    lines.push('');
  }

  return lines;
}

/**
 * Format a single issue group
 * Shows all CRITICAL/HIGH issues, limits LOW/MEDIUM to 5
 */
function formatGroup(group: IssueGroup): string[] {
  const lines: string[] = [];
  const icon = getPriorityIcon(group.priority);

  lines.push(`### ${icon} ${group.title}`);
  lines.push('');
  lines.push(`> ${group.description}`);
  lines.push(
    `> **Effort**: ${group.totalEffort.timeLabel} | **Auto-fixable**: ${group.autoFixableCount}/${group.count}`,
  );
  lines.push('');

  // Show all CRITICAL/HIGH, limit LOW/MEDIUM to 5
  const showAll = group.priority === 'critical' || group.priority === 'high';
  const maxIssues = showAll ? group.issues.length : 5;

  for (const enriched of group.issues.slice(0, maxIssues)) {
    lines.push(formatEnrichedIssue(enriched));
  }

  if (group.issues.length > maxIssues) {
    lines.push(`- ... and ${group.issues.length - maxIssues} more issues`);
  }

  lines.push('');
  return lines;
}

/**
 * Format a single enriched issue
 */
function formatEnrichedIssue(enriched: EnrichedIssue): string {
  const { issue, effort, autoFixable } = enriched;
  const file = normalizePath(issue.file);
  const loc = issue.line ? `:${issue.line}` : '';
  const autoTag = autoFixable ? ' [AUTO]' : '';

  return `- [ ] \`${file}${loc}\` ‚Äî ${issue.message} (${effort.timeLabel})${autoTag}`;
}

/**
 * Format an action step
 * CRITICAL issues: inline snippet (need to see immediately)
 * Other issues: collapsible snippet (saves space)
 */
function formatActionStep(step: ActionStep): string[] {
  const lines: string[] = [];
  const file = normalizePath(step.file);
  const loc = step.line ? `:${step.line}` : '';
  const actionIcon = getActionIcon(step.action);
  const priorityIcon = getPriorityIcon(step.priority);

  lines.push(`#### ${step.id}: ${actionIcon} ${step.action.toUpperCase()} ${priorityIcon}`);
  lines.push('');
  lines.push(`**File**: \`${file}${loc}\``);
  lines.push(`**Effort**: ${step.effort.timeLabel}`);
  lines.push('');
  lines.push(`${step.description}`);
  lines.push('');

  // Show code snippet based on priority
  // Use trimEnd() to preserve leading markers (‚Üí) while removing trailing whitespace
  if (step.snippet) {
    const cleanSnippet = step.snippet.trimEnd();
    const snippetLines = cleanSnippet.split('\n').length;

    if (step.priority === 'critical') {
      // CRITICAL: inline snippet (need to see immediately)
      lines.push('**Current code:**');
      lines.push('```typescript');
      lines.push(cleanSnippet);
      lines.push('```');
      lines.push('');
    } else {
      // HIGH/MEDIUM/LOW: collapsible snippet (saves space)
      lines.push('<details>');
      lines.push(
        `<summary>üìù Show code context (${snippetLines} line${snippetLines > 1 ? 's' : ''})</summary>`,
      );
      lines.push('');
      lines.push('```typescript');
      lines.push(cleanSnippet);
      lines.push('```');
      lines.push('');
      lines.push('</details>');
      lines.push('');
    }
  }

  if (step.suggestion) {
    if (step.priority === 'critical') {
      // CRITICAL: inline suggestion
      lines.push('**Suggested fix:**');
      lines.push('```diff');
      if (step.suggestion.before) {
        lines.push(`- ${step.suggestion.before}`);
      }
      lines.push(`+ ${step.suggestion.after}`);
      lines.push('```');
      lines.push('');
      lines.push(`> ${step.suggestion.reason}`);
      lines.push('');
    } else {
      // Non-critical: collapsible suggestion
      lines.push('<details>');
      lines.push('<summary>üí° Show suggested fix</summary>');
      lines.push('');
      lines.push('```diff');
      if (step.suggestion.before) {
        lines.push(`- ${step.suggestion.before}`);
      }
      lines.push(`+ ${step.suggestion.after}`);
      lines.push('```');
      lines.push('');
      lines.push(`> ${step.suggestion.reason}`);
      lines.push('');
      lines.push('</details>');
      lines.push('');
    }
  }

  return lines;
}

/**
 * Get icon for priority level
 */
function getPriorityIcon(priority: PriorityLevel): string {
  const icons: Record<PriorityLevel, string> = {
    critical: 'üî¥',
    high: 'üü†',
    medium: 'üü°',
    low: 'üü¢',
  };
  return icons[priority];
}

/**
 * Get icon for action type
 */
function getActionIcon(action: ActionStep['action']): string {
  const icons: Record<ActionStep['action'], string> = {
    fix: 'üîß',
    refactor: 'üîÑ',
    review: 'üëÄ',
    skip: '‚è≠Ô∏è',
  };
  return icons[action];
}

// ============================================================================
// JSON FORMATTER
// ============================================================================

/**
 * Format AI Report as JSON
 */
export function formatAsJson(report: AIReport): string {
  return JSON.stringify(report, null, 2);
}

// ============================================================================
// XML FORMATTER
// ============================================================================

/**
 * Format AI Report as XML (AI-friendly format)
 */
export function formatAsXml(report: AIReport): string {
  const lines: string[] = [];

  lines.push('<ai-report>');
  lines.push(`  <meta version="${report.meta.version}" generated="${report.meta.generatedAt}" />`);
  lines.push('');

  // Summary
  lines.push('  <summary>');
  lines.push(`    <total-issues>${report.summary.totalIssues}</total-issues>`);
  lines.push(`    <auto-fixable>${report.summary.autoFixableIssues}</auto-fixable>`);
  lines.push(`    <manual-required>${report.summary.manualIssues}</manual-required>`);
  lines.push(
    `    <total-effort minutes="${report.summary.totalEffortMinutes}">${report.summary.totalEffortLabel}</total-effort>`,
  );
  lines.push('  </summary>');
  lines.push('');

  // Quick wins
  if (report.quickWins.length > 0) {
    lines.push('  <quick-wins>');
    for (const win of report.quickWins) {
      const loc = win.issue.line ? `:${win.issue.line}` : '';
      lines.push(`    <issue file="${win.issue.file}${loc}" effort="${win.effort.timeLabel}">`);
      lines.push(`      ${escapeXml(win.issue.message)}`);
      lines.push('    </issue>');
    }
    lines.push('  </quick-wins>');
    lines.push('');
  }

  // Action plan
  if (report.actionPlan.length > 0) {
    lines.push('  <action-plan>');
    for (const step of report.actionPlan) {
      const loc = step.line ? `:${step.line}` : '';
      lines.push(
        `    <step id="${step.id}" action="${step.action}" file="${step.file}${loc}" effort="${step.effort.timeLabel}">`,
      );
      lines.push(`      <description>${escapeXml(step.description)}</description>`);
      if (step.suggestion) {
        lines.push(`      <suggestion reason="${escapeXml(step.suggestion.reason)}">`);
        lines.push(`        ${escapeXml(step.suggestion.after)}`);
        lines.push('      </suggestion>');
      }
      lines.push('    </step>');
    }
    lines.push('  </action-plan>');
  }

  // Ranking (dependency hotspots + safe refactoring order)
  if (report.ranking && report.ranking.hotspots.length > 0) {
    lines.push('');
    lines.push('  <!-- RANKING - PageRank-based dependency analysis -->');
    lines.push(
      `  <ranking modules="${report.ranking.stats.nodeCount}" edges="${report.ranking.stats.edgeCount}" cycles="${report.ranking.stats.cycleCount}">`,
    );

    // Hotspots
    lines.push(`    <hotspots count="${report.ranking.hotspots.length}">`);
    for (const hotspot of report.ranking.hotspots.slice(0, 10)) {
      lines.push(
        `      <hotspot path="${escapeXml(hotspot.path)}" percentile="${hotspot.percentile}" risk="${hotspot.risk}">`,
      );
      lines.push(
        `        <metrics pagerank="${hotspot.pageRank.toFixed(4)}" ca="${hotspot.coupling.afferent}" ce="${hotspot.coupling.efferent}" instability="${hotspot.coupling.instability.toFixed(2)}" />`,
      );
      lines.push('      </hotspot>');
    }
    lines.push('    </hotspots>');

    // Safe refactoring order
    if (report.ranking.safeOrder.length > 0) {
      lines.push(`    <safe-order phases="${report.ranking.safeOrder.length}">`);
      for (const phase of report.ranking.safeOrder.slice(0, 5)) {
        const modules = phase.modules.join(', ');
        lines.push(
          `      <phase order="${phase.order}" modules="${phase.modules.length}" risk="${phase.risk}">${modules}</phase>`,
        );
      }
      lines.push('    </safe-order>');
    }

    // Cycles (if any)
    if (report.ranking.cycles.length > 0) {
      lines.push(`    <cycles count="${report.ranking.cycles.length}">`);
      for (const cycle of report.ranking.cycles.slice(0, 3)) {
        lines.push(`      <cycle>${cycle.join(' ‚Üí ')}</cycle>`);
      }
      lines.push('    </cycles>');
    }

    // Leaf/Core nodes
    if (report.ranking.leafNodes.length > 0) {
      lines.push(
        `    <leaf-nodes hint="safe to refactor first">${report.ranking.leafNodes.slice(0, 5).join(', ')}</leaf-nodes>`,
      );
    }
    if (report.ranking.coreNodes.length > 0) {
      lines.push(
        `    <core-nodes hint="refactor last">${report.ranking.coreNodes.join(', ')}</core-nodes>`,
      );
    }

    lines.push('    <hint>Run: krolik refactor for full analysis and migration plan</hint>');
    lines.push('  </ranking>');
  }

  // Backwards-compat shim files (should be deleted)
  if (report.backwardsCompatFiles && report.backwardsCompatFiles.length > 0) {
    lines.push('');
    lines.push('  <!-- BACKWARDS-COMPAT - Deprecated shim files that should be deleted -->');
    lines.push(
      `  <backwards-compat count="${report.backwardsCompatFiles.length}" action="delete">`,
    );
    for (const file of report.backwardsCompatFiles) {
      lines.push(
        `    <shim path="${escapeXml(file.path)}" confidence="${file.confidence}%"${file.movedTo ? ` target="${escapeXml(file.movedTo)}"` : ''}>`,
      );
      lines.push(`      <reason>${escapeXml(file.reason)}</reason>`);
      lines.push(`      <suggestion>${escapeXml(file.suggestion)}</suggestion>`);
      lines.push('    </shim>');
    }
    lines.push('    <hint>Delete these files and update imports to use the new locations</hint>');
    lines.push('  </backwards-compat>');
  }

  // Recommendations (top 10 from refactor analysis)
  if (report.recommendations && report.recommendations.length > 0) {
    lines.push('');
    lines.push('  <!-- RECOMMENDATIONS - Top refactoring priorities -->');
    lines.push(`  <recommendations count="${report.recommendations.length}">`);
    for (const rec of report.recommendations) {
      lines.push(
        `    <rec priority="${rec.priority}" category="${rec.category}" effort="${rec.effort}" auto="${rec.autoFixable}">`,
      );
      lines.push(`      <title>${escapeXml(rec.title)}</title>`);
      lines.push(`      <description>${escapeXml(rec.description)}</description>`);
      if (rec.affectedFiles.length > 0) {
        lines.push(`      <files>${rec.affectedFiles.map((f) => escapeXml(f)).join(', ')}</files>`);
      }
      lines.push('    </rec>');
    }
    lines.push('  </recommendations>');
  }

  // Duplicates summary
  if (report.duplicates && report.duplicates.totalGroups > 0) {
    lines.push('');
    lines.push('  <!-- DUPLICATES - Function duplicates summary -->');
    lines.push(
      `  <duplicates total="${report.duplicates.totalGroups}" merge="${report.duplicates.mergeCount}" rename="${report.duplicates.renameCount}">`,
    );
    for (const dup of report.duplicates.topDuplicates.slice(0, 5)) {
      lines.push(
        `    <dup name="${escapeXml(dup.name)}" similarity="${(dup.similarity * 100).toFixed(0)}%" locations="${dup.locationCount}" action="${dup.recommendation}">`,
      );
      lines.push(`      <files>${dup.files.map((f) => escapeXml(f)).join(', ')}</files>`);
      lines.push('    </dup>');
    }
    lines.push(
      '    <hint>Run: krolik refactor --duplicates-only for full duplicate analysis</hint>',
    );
    lines.push('  </duplicates>');
  }

  lines.push('</ai-report>');

  return lines.join('\n');
}
