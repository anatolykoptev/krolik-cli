/**
 * @module commands/fix/reporter/formatter
 * @description Formatters for AI Report output
 */

import { escapeXml } from '../../../lib/@format';
import { formatCodeContextAsXml, formatGitContextXml } from '../../audit/enrichment';
import { formatProgressiveOutput, type OutputLevel } from '../../audit/output';
import type { TypeContext } from '../../audit/suggestions';
import { normalizePath } from './grouping';
import type {
  ActionStep,
  AIReport,
  EnrichedIssue,
  FileContext,
  IssueCluster,
  IssueGroup,
  IssuePattern,
  PriorityLevel,
} from './types';

// ============================================================================
// MARKDOWN FORMATTER
// ============================================================================

/**
 * Format AI Report as Markdown
 */
export function formatAsMarkdown(report: AIReport): string {
  const lines: string[] = [];

  // Header
  lines.push('# AI Code Quality Report');
  lines.push('');
  lines.push(`> Generated by krolik-cli at ${report.meta.generatedAt}`);
  lines.push('');

  // Summary
  lines.push('## Summary');
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Total Issues | ${report.summary.totalIssues} |`);
  lines.push(`| Auto-fixable | ${report.summary.autoFixableIssues} |`);
  lines.push(`| Manual Required | ${report.summary.manualIssues} |`);
  lines.push(`| Total Effort | ${report.summary.totalEffortLabel} |`);
  lines.push('');

  // Priority breakdown
  lines.push('### By Priority');
  lines.push('');
  const priorities: PriorityLevel[] = ['critical', 'high', 'medium', 'low'];
  for (const priority of priorities) {
    const count = report.summary.byPriority[priority];
    if (count > 0) {
      const icon = getPriorityIcon(priority);
      lines.push(`- ${icon} **${priority.toUpperCase()}**: ${count} issues`);
    }
  }
  lines.push('');

  // Context
  if (report.context.techStack && report.context.techStack.length > 0) {
    lines.push('### Tech Stack');
    lines.push('');
    lines.push(report.context.techStack.join(', '));
    lines.push('');
  }

  // AI Rules (CRITICAL - must read first!)
  if (report.aiRules && report.aiRules.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## ‚ö†Ô∏è AI Rules (Read First!)');
    lines.push('');
    lines.push(
      '> **IMPORTANT:** Before starting any work, read these files for project-specific rules and conventions.',
    );
    lines.push('');
    for (const rule of report.aiRules) {
      lines.push(`- \`${rule.path}\` (${rule.scope})`);
    }
    lines.push('');
  }

  // Git Status
  if (report.git) {
    lines.push('---');
    lines.push('');
    lines.push('## Git Status');
    lines.push('');
    lines.push(`- **Branch:** \`${report.git.branch}\``);
    lines.push(
      `- **Changes:** ${report.git.modified} modified, ${report.git.untracked} untracked, ${report.git.staged} staged`,
    );
    lines.push('');
    if (report.git.recentCommits.length > 0) {
      lines.push('### Recent Commits');
      lines.push('');
      for (const commit of report.git.recentCommits.slice(0, 3)) {
        lines.push(`- \`${commit.hash}\` ${commit.message} *(${commit.relativeDate})*`);
      }
      lines.push('');
    }
  }

  // Next Action
  if (report.nextAction) {
    lines.push('---');
    lines.push('');
    lines.push('## üéØ Next Action');
    lines.push('');
    const priorityIcon =
      report.nextAction.priority === 'critical'
        ? 'üî¥'
        : report.nextAction.priority === 'high'
          ? 'üü†'
          : report.nextAction.priority === 'medium'
            ? 'üü°'
            : 'üü¢';
    lines.push(`**${priorityIcon} ${report.nextAction.action}**`);
    if (report.nextAction.reason) {
      lines.push('');
      lines.push(`> ${report.nextAction.reason}`);
    }
    lines.push('');
  }

  // Do-Not Rules
  if (report.doNot && report.doNot.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## üö´ Do Not');
    lines.push('');
    for (const rule of report.doNot) {
      lines.push(`- ${rule}`);
    }
    lines.push('');
  }

  // Quick Wins
  if (report.quickWins.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Quick Wins');
    lines.push('');
    lines.push('These issues can be auto-fixed in seconds:');
    lines.push('');

    for (const win of report.quickWins) {
      const loc = win.issue.line ? `:${win.issue.line}` : '';
      lines.push(
        `- [ ] \`${win.issue.file}${loc}\` ‚Äî ${win.issue.message} (${win.effort.timeLabel})`,
      );
    }
    lines.push('');
  }

  // Hotspots
  if (report.hotspots.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Hotspot Files');
    lines.push('');
    lines.push('Files with the most issues:');
    lines.push('');
    lines.push('| File | Issues | Priority |');
    lines.push('|------|--------|----------|');

    for (const hotspot of report.hotspots.slice(0, 5)) {
      const icon = getPriorityIcon(hotspot.priority);
      lines.push(`| \`${hotspot.file}\` | ${hotspot.issueCount} | ${icon} ${hotspot.priority} |`);
    }
    lines.push('');
  }

  // Issue Groups
  lines.push('---');
  lines.push('');
  lines.push('## Issues by Priority');
  lines.push('');

  for (const group of report.groups) {
    lines.push(...formatGroup(group));
  }

  // Action Plan
  if (report.actionPlan.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Recommended Action Plan');
    lines.push('');
    lines.push('Execute these steps in order:');
    lines.push('');

    for (const step of report.actionPlan.slice(0, 5)) {
      lines.push(...formatActionStep(step));
    }
  }

  // File Contexts (only files with issues, top 15)
  if (report.fileContexts && report.fileContexts.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## File Contexts');
    lines.push('');
    lines.push('Detailed information about affected files:');
    lines.push('');

    for (const ctx of report.fileContexts) {
      lines.push(...formatFileContext(ctx));
    }
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*Use `krolik fix --ai-execute AI-REPORT.md` to execute this plan automatically.*');
  lines.push('');

  return lines.join('\n');
}

/**
 * Format a single file context
 */
function formatFileContext(ctx: FileContext): string[] {
  const lines: string[] = [];

  lines.push(`### \`${ctx.path}\``);
  lines.push('');
  lines.push(`- **Purpose**: ${ctx.purpose}`);
  lines.push(`- **Type**: ${ctx.type}`);
  lines.push(
    `- **Metrics**: ${ctx.metrics.lines} lines, ${ctx.metrics.functions} functions, avg complexity ${ctx.metrics.avgComplexity}`,
  );
  lines.push('');

  if (ctx.exports.length > 0) {
    lines.push(`**Exports**: \`${ctx.exports.join('`, `')}\``);
    lines.push('');
  }

  if (ctx.imports.length > 0) {
    lines.push(`**Imports**: ${ctx.imports.map((i) => `\`${i}\``).join(', ')}`);
    lines.push('');
  }

  return lines;
}

/**
 * Format a single issue group
 * Shows all CRITICAL/HIGH issues, limits LOW/MEDIUM to 5
 */
function formatGroup(group: IssueGroup): string[] {
  const lines: string[] = [];
  const icon = getPriorityIcon(group.priority);

  lines.push(`### ${icon} ${group.title}`);
  lines.push('');
  lines.push(`> ${group.description}`);
  lines.push(
    `> **Effort**: ${group.totalEffort.timeLabel} | **Auto-fixable**: ${group.autoFixableCount}/${group.count}`,
  );
  lines.push('');

  // Show all CRITICAL/HIGH, limit LOW/MEDIUM to 5
  const showAll = group.priority === 'critical' || group.priority === 'high';
  const maxIssues = showAll ? group.issues.length : 5;

  for (const enriched of group.issues.slice(0, maxIssues)) {
    lines.push(formatEnrichedIssue(enriched));
  }

  if (group.issues.length > maxIssues) {
    lines.push(`- ... and ${group.issues.length - maxIssues} more issues`);
  }

  lines.push('');
  return lines;
}

/**
 * Format a single enriched issue
 */
function formatEnrichedIssue(enriched: EnrichedIssue): string {
  const { issue, effort, autoFixable } = enriched;
  const file = normalizePath(issue.file);
  const loc = issue.line ? `:${issue.line}` : '';
  const autoTag = autoFixable ? ' [AUTO]' : '';

  return `- [ ] \`${file}${loc}\` ‚Äî ${issue.message} (${effort.timeLabel})${autoTag}`;
}

/**
 * Format an action step
 * CRITICAL issues: inline snippet (need to see immediately)
 * Other issues: collapsible snippet (saves space)
 */
function formatActionStep(step: ActionStep): string[] {
  const lines: string[] = [];
  const file = normalizePath(step.file);
  const loc = step.line ? `:${step.line}` : '';
  const actionIcon = getActionIcon(step.action);
  const priorityIcon = getPriorityIcon(step.priority);

  lines.push(`#### ${step.id}: ${actionIcon} ${step.action.toUpperCase()} ${priorityIcon}`);
  lines.push('');
  lines.push(`**File**: \`${file}${loc}\``);
  lines.push(`**Effort**: ${step.effort.timeLabel}`);
  lines.push('');
  lines.push(`${step.description}`);
  lines.push('');

  // Show code snippet based on priority
  // Use trimEnd() to preserve leading markers (‚Üí) while removing trailing whitespace
  if (step.snippet) {
    const cleanSnippet = step.snippet.trimEnd();
    const snippetLines = cleanSnippet.split('\n').length;

    if (step.priority === 'critical') {
      // CRITICAL: inline snippet (need to see immediately)
      lines.push('**Current code:**');
      lines.push('```typescript');
      lines.push(cleanSnippet);
      lines.push('```');
      lines.push('');
    } else {
      // HIGH/MEDIUM/LOW: collapsible snippet (saves space)
      lines.push('<details>');
      lines.push(
        `<summary>üìù Show code context (${snippetLines} line${snippetLines > 1 ? 's' : ''})</summary>`,
      );
      lines.push('');
      lines.push('```typescript');
      lines.push(cleanSnippet);
      lines.push('```');
      lines.push('');
      lines.push('</details>');
      lines.push('');
    }
  }

  if (step.suggestion) {
    if (step.priority === 'critical') {
      // CRITICAL: inline suggestion
      lines.push('**Suggested fix:**');
      lines.push('```diff');
      if (step.suggestion.before) {
        lines.push(`- ${step.suggestion.before}`);
      }
      lines.push(`+ ${step.suggestion.after}`);
      lines.push('```');
      lines.push('');
      lines.push(`> ${step.suggestion.reason}`);
      lines.push('');
    } else {
      // Non-critical: collapsible suggestion
      lines.push('<details>');
      lines.push('<summary>üí° Show suggested fix</summary>');
      lines.push('');
      lines.push('```diff');
      if (step.suggestion.before) {
        lines.push(`- ${step.suggestion.before}`);
      }
      lines.push(`+ ${step.suggestion.after}`);
      lines.push('```');
      lines.push('');
      lines.push(`> ${step.suggestion.reason}`);
      lines.push('');
      lines.push('</details>');
      lines.push('');
    }
  }

  return lines;
}

/**
 * Get icon for priority level
 */
function getPriorityIcon(priority: PriorityLevel): string {
  const icons: Record<PriorityLevel, string> = {
    critical: 'üî¥',
    high: 'üü†',
    medium: 'üü°',
    low: 'üü¢',
  };
  return icons[priority];
}

/**
 * Get icon for action type
 */
function getActionIcon(action: ActionStep['action']): string {
  const icons: Record<ActionStep['action'], string> = {
    fix: 'üîß',
    refactor: 'üîÑ',
    review: 'üëÄ',
    skip: '‚è≠Ô∏è',
  };
  return icons[action];
}

// ============================================================================
// JSON FORMATTER
// ============================================================================

/**
 * Format AI Report as JSON
 */
export function formatAsJson(report: AIReport): string {
  return JSON.stringify(report, null, 2);
}

// ============================================================================
// PROGRESSIVE XML FORMATTER
// ============================================================================

/**
 * Format AI Report as progressive XML with token budgets
 *
 * Provides 3-level output:
 * - 'summary': Executive summary only (~50 tokens)
 * - 'default': Executive summary + top issues (~500 tokens)
 * - 'full': Complete report
 *
 * @param report - The AI report to format
 * @param level - Output level for token budget
 * @returns Formatted XML string within token budget
 *
 * @example
 * // Default output (~500 tokens)
 * const xml = formatAsProgressiveXml(report, 'default');
 *
 * // Summary only (~50 tokens)
 * const summary = formatAsProgressiveXml(report, 'summary');
 */
export function formatAsProgressiveXml(report: AIReport, level: OutputLevel = 'default'): string {
  return formatProgressiveOutput(report, level);
}

// ============================================================================
// ISSUE PATTERN FORMATTER
// ============================================================================

/**
 * Format issue patterns as XML for smart audit output
 *
 * Creates the target format:
 * ```xml
 * <issue-group category="type-safety" pattern="any-usage" count="23">
 *   <batch-fix available="true">
 *     <command>krolik fix --pattern any-to-unknown</command>
 *     <files-affected>8</files-affected>
 *     <auto-fixable>15</auto-fixable>
 *     <manual-required>8</manual-required>
 *   </batch-fix>
 *   <by-file>
 *     <file path="utils.ts" count="6" auto="4"/>
 *   </by-file>
 * </issue-group>
 * ```
 */
function formatIssuePatterns(patterns: IssuePattern[]): string[] {
  const lines: string[] = [];

  for (const pattern of patterns) {
    lines.push(
      `  <issue-group category="${pattern.category}" pattern="${pattern.pattern}" count="${pattern.issues.length}">`,
    );

    // Batch fix info
    lines.push(`    <batch-fix available="${pattern.batchFix.available}">`);
    if (pattern.batchFix.available && pattern.batchFix.command) {
      lines.push(`      <command>${escapeXml(pattern.batchFix.command)}</command>`);
    }
    lines.push(`      <files-affected>${pattern.batchFix.filesAffected}</files-affected>`);
    lines.push(`      <auto-fixable>${pattern.batchFix.autoFixable}</auto-fixable>`);
    lines.push(`      <manual-required>${pattern.batchFix.manualRequired}</manual-required>`);
    lines.push('    </batch-fix>');

    // By-file breakdown (limit to top 10 files)
    if (pattern.byFile.length > 0) {
      lines.push('    <by-file>');
      for (const file of pattern.byFile.slice(0, 10)) {
        lines.push(
          `      <file path="${escapeXml(file.path)}" count="${file.count}" auto="${file.auto}"/>`,
        );
      }
      if (pattern.byFile.length > 10) {
        lines.push(`      <!-- ... and ${pattern.byFile.length - 10} more files -->`);
      }
      lines.push('    </by-file>');
    }

    // Show sample issues with suggestions (limit to 3)
    const issuesWithSuggestions = pattern.issues.filter((i) => i.suggestion).slice(0, 3);
    if (issuesWithSuggestions.length > 0) {
      lines.push('    <sample-issues>');
      for (const enriched of issuesWithSuggestions) {
        const loc = enriched.issue.line ? `:${enriched.issue.line}` : '';
        lines.push(`      <issue file="${escapeXml(enriched.issue.file)}${loc}">`);
        lines.push(`        <description>${escapeXml(enriched.issue.message)}</description>`);
        if (enriched.suggestion) {
          lines.push(...formatSuggestionXml(enriched.suggestion, 8));
        }
        lines.push('      </issue>');
      }
      lines.push('    </sample-issues>');
    }

    lines.push('  </issue-group>');
  }

  return lines;
}

// ============================================================================
// ISSUE CLUSTER FORMATTER
// ============================================================================

/**
 * Format issue clusters as XML for smart audit output
 *
 * Creates the target format:
 * ```xml
 * <issue-cluster file="utils.ts" category="any-type" count="4">
 *   <root-cause>Functions lack proper generic types</root-cause>
 *   <fix-together>true</fix-together>
 *   <locations>97, 193, 232, 256</locations>
 *   <suggested-approach>Add generic type parameters to functions</suggested-approach>
 * </issue-cluster>
 * ```
 */
function formatIssueClusters(clusters: IssueCluster[]): string[] {
  const lines: string[] = [];

  for (const cluster of clusters) {
    lines.push(
      `  <issue-cluster file="${escapeXml(cluster.file)}" category="${escapeXml(cluster.category)}" count="${cluster.count}">`,
    );
    lines.push(`    <root-cause>${escapeXml(cluster.rootCause)}</root-cause>`);
    lines.push(`    <fix-together>${cluster.fixTogether}</fix-together>`);
    lines.push(`    <locations>${cluster.locations.join(', ')}</locations>`);
    lines.push(
      `    <suggested-approach>${escapeXml(cluster.suggestedApproach)}</suggested-approach>`,
    );

    // Add file-level impact info if available (take from first issue)
    const firstIssueWithImpact = cluster.issues.find((i) => i.impact);
    if (firstIssueWithImpact?.impact) {
      const imp = firstIssueWithImpact.impact;
      lines.push(`    <impact dependents="${imp.dependents}" risk="${imp.riskLevel}">`);
      if (imp.dependentFiles && imp.dependentFiles.length > 0) {
        lines.push('      <top-dependents>');
        for (const file of imp.dependentFiles.slice(0, 3)) {
          lines.push(`        <file>${escapeXml(file)}</file>`);
        }
        lines.push('      </top-dependents>');
      }
      if (imp.riskReason) {
        lines.push(`      <risk-reason>${escapeXml(imp.riskReason)}</risk-reason>`);
      }
      lines.push('    </impact>');
    }

    // Show sample issues (limit to 3)
    if (cluster.issues.length > 0) {
      const sampleIssues = cluster.issues.slice(0, 3);
      lines.push('    <sample-issues>');
      for (const enriched of sampleIssues) {
        lines.push(`      <issue line="${enriched.issue.line ?? 0}">`);
        lines.push(`        <description>${escapeXml(enriched.issue.message)}</description>`);
        // Include git context for high-complexity or critical issues
        if (enriched.gitContext) {
          lines.push(...formatGitContextXml(enriched.gitContext, 8));
        }
        if (enriched.suggestion) {
          lines.push(...formatSuggestionXml(enriched.suggestion, 8));
        }
        lines.push('      </issue>');
      }
      if (cluster.issues.length > 3) {
        lines.push(`      <!-- ... and ${cluster.issues.length - 3} more issues -->`);
      }
      lines.push('    </sample-issues>');
    }

    lines.push('  </issue-cluster>');
  }

  return lines;
}

// ============================================================================
// IMPACT FORMATTER
// ============================================================================

/**
 * Format ImpactScore as XML for issue enrichment
 *
 * Supports two output modes:
 * - Basic: dependents count, bug history, change frequency
 * - Extended: includes top-dependents list and risk-reason
 *
 * @param impact - The impact score to format
 * @param indent - Number of spaces to indent (default: 0)
 * @returns Array of XML lines
 *
 * @example Basic output
 * ```xml
 * <impact>
 *   <dependents count="50"/>
 *   <bug-history count="4" period="30d"/>
 *   <change-frequency rank="top-5%"/>
 * </impact>
 * <risk>critical</risk>
 * ```
 *
 * @example Extended output (with dependentFiles and riskReason)
 * ```xml
 * <impact dependents="12" risk="high">
 *   <top-dependents>
 *     <file>routers/booking.ts</file>
 *     <file>components/SlotPicker.tsx</file>
 *   </top-dependents>
 *   <risk-reason>Core booking logic, 95th percentile centrality</risk-reason>
 * </impact>
 * ```
 */
function formatImpactXml(
  impact: {
    dependents: number;
    bugHistory: number;
    changeFrequency: number;
    percentile: number;
    riskLevel: string;
    dependentFiles?: string[];
    riskReason?: string;
  },
  indent = 0,
): string[] {
  const pad = ' '.repeat(indent);
  const lines: string[] = [];

  // Use extended format if dependentFiles or riskReason is available
  if (impact.dependentFiles || impact.riskReason) {
    lines.push(`${pad}<impact dependents="${impact.dependents}" risk="${impact.riskLevel}">`);

    // Top dependents
    if (impact.dependentFiles && impact.dependentFiles.length > 0) {
      lines.push(`${pad}  <top-dependents>`);
      for (const file of impact.dependentFiles.slice(0, 5)) {
        lines.push(`${pad}    <file>${escapeXml(file)}</file>`);
      }
      lines.push(`${pad}  </top-dependents>`);
    }

    // Risk reason
    if (impact.riskReason) {
      lines.push(`${pad}  <risk-reason>${escapeXml(impact.riskReason)}</risk-reason>`);
    }

    lines.push(`${pad}</impact>`);
  } else {
    // Basic format (backwards compatible)
    const changeRank = formatChangeRank(impact.percentile);

    lines.push(`${pad}<impact>`);
    lines.push(`${pad}  <dependents count="${impact.dependents}"/>`);
    lines.push(`${pad}  <bug-history count="${impact.bugHistory}" period="30d"/>`);
    lines.push(`${pad}  <change-frequency rank="${changeRank}"/>`);
    lines.push(`${pad}</impact>`);
    lines.push(`${pad}<risk>${impact.riskLevel}</risk>`);
  }

  return lines;
}

/**
 * Format percentile as human-readable rank
 */
function formatChangeRank(percentile: number): string {
  if (percentile >= 95) return 'top-5%';
  if (percentile >= 90) return 'top-10%';
  if (percentile >= 80) return 'top-20%';
  if (percentile >= 50) return 'top-50%';
  return 'bottom-50%';
}

// ============================================================================
// SUGGESTION FORMATTER
// ============================================================================

/**
 * Format a Suggestion as XML with before/after and reasoning
 *
 * Includes type inference context when available for `any` type issues.
 *
 * @param suggestion - The suggestion to format
 * @param indent - Number of spaces to indent (default: 0)
 * @returns Array of XML lines
 *
 * @example
 * ```xml
 * <suggestion confidence="87%">
 *   <before><![CDATA[const handler: any = (req) => ...]]></before>
 *   <after><![CDATA[const handler: RequestHandler = (req) => ...]]></after>
 *   <reasoning>Inferred RequestHandler from usage (high confidence)</reasoning>
 *   <type-inference inferred="RequestHandler" confidence="87%">
 *     <evidence>
 *       <usage type="method-call" line="15">req.body accessed as object</usage>
 *       <usage type="return" line="18">returns Promise&lt;Response&gt;</usage>
 *     </evidence>
 *   </type-inference>
 * </suggestion>
 * ```
 */
function formatSuggestionXml(
  suggestion: {
    before: string;
    after: string;
    reasoning: string;
    confidence: number;
    typeContext?: TypeContext | undefined;
  },
  indent = 0,
): string[] {
  const pad = ' '.repeat(indent);
  const lines: string[] = [];

  lines.push(`${pad}<suggestion confidence="${suggestion.confidence}%">`);
  lines.push(`${pad}  <before><![CDATA[${suggestion.before}]]></before>`);
  lines.push(`${pad}  <after><![CDATA[${suggestion.after}]]></after>`);
  lines.push(`${pad}  <reasoning>${escapeXml(suggestion.reasoning)}</reasoning>`);

  // Add type inference context for type-safety issues
  if (suggestion.typeContext) {
    const tc = suggestion.typeContext;
    lines.push(
      `${pad}  <type-inference inferred="${escapeXml(tc.inferredType)}" confidence="${tc.confidence}%">`,
    );
    if (tc.evidence.length > 0) {
      lines.push(`${pad}    <evidence>`);
      for (const e of tc.evidence.slice(0, 5)) {
        const lineAttr = e.line ? ` line="${e.line}"` : '';
        lines.push(
          `${pad}      <usage type="${e.type}"${lineAttr}>${escapeXml(e.description)}</usage>`,
        );
      }
      if (tc.evidence.length > 5) {
        lines.push(`${pad}      <!-- ... and ${tc.evidence.length - 5} more usages -->`);
      }
      lines.push(`${pad}    </evidence>`);
    }
    lines.push(`${pad}  </type-inference>`);
  }

  lines.push(`${pad}</suggestion>`);

  return lines;
}

// ============================================================================
// XML FORMATTER
// ============================================================================

/**
 * Format AI Report as XML (AI-friendly format)
 */
export function formatAsXml(report: AIReport): string {
  const lines: string[] = [];

  lines.push('<ai-report>');
  lines.push(`  <meta version="${report.meta.version}" generated="${report.meta.generatedAt}" />`);
  lines.push('');

  // Summary with Google-style severity breakdown
  lines.push('  <summary>');
  lines.push(`    <total-issues>${report.summary.totalIssues}</total-issues>`);
  lines.push(`    <auto-fixable>${report.summary.autoFixableIssues}</auto-fixable>`);
  lines.push(`    <manual-required>${report.summary.manualIssues}</manual-required>`);
  lines.push(
    `    <total-effort minutes="${report.summary.totalEffortMinutes}">${report.summary.totalEffortLabel}</total-effort>`,
  );

  // Google-style severity breakdown (priority ‚Üí severity mapping)
  const bySeverity = {
    'must-fix': report.summary.byPriority.critical ?? 0,
    'should-fix': report.summary.byPriority.high ?? 0,
    nit: report.summary.byPriority.medium ?? 0,
    optional: report.summary.byPriority.low ?? 0,
  };
  lines.push('    <by-severity google-style="true">');
  lines.push(`      <must-fix blocking="true">${bySeverity['must-fix']}</must-fix>`);
  lines.push(`      <should-fix>${bySeverity['should-fix']}</should-fix>`);
  lines.push(`      <nit>${bySeverity.nit}</nit>`);
  lines.push(`      <optional>${bySeverity.optional}</optional>`);
  lines.push('    </by-severity>');

  lines.push('  </summary>');
  lines.push('');

  // Quick wins
  if (report.quickWins.length > 0) {
    lines.push('  <quick-wins>');
    for (const win of report.quickWins) {
      const loc = win.issue.line ? `:${win.issue.line}` : '';
      const severityAttr = win.severity ? ` severity="${win.severity}"` : '';
      const confidenceAttr = win.confidence ? ` confidence="${win.confidence.score}%"` : '';
      lines.push(
        `    <issue file="${win.issue.file}${loc}" effort="${win.effort.timeLabel}" priority="${win.priority}"${severityAttr}${confidenceAttr}>`,
      );
      lines.push(`      <description>${escapeXml(win.issue.message)}</description>`);
      // Include impact if available
      if (win.impact) {
        lines.push(...formatImpactXml(win.impact, 6));
      }
      // Include git context for high-complexity or critical issues
      if (win.gitContext) {
        lines.push(...formatGitContextXml(win.gitContext, 6));
      }
      // Include suggestion if available
      if (win.suggestion) {
        lines.push(...formatSuggestionXml(win.suggestion, 6));
      }
      // Include code context (snippet + complexity breakdown) if available
      if (win.codeContext) {
        const codeContextXml = formatCodeContextAsXml(win.codeContext, 6);
        if (codeContextXml) {
          lines.push(codeContextXml);
        }
      }
      lines.push('    </issue>');
    }
    lines.push('  </quick-wins>');
    lines.push('');
  }

  // Action plan with Google-style severity
  if (report.actionPlan.length > 0) {
    lines.push('  <action-plan>');
    for (const step of report.actionPlan) {
      const loc = step.line ? `:${step.line}` : '';
      // Map priority to Google-style severity
      const severityMap: Record<string, string> = {
        critical: 'must-fix',
        high: 'should-fix',
        medium: 'nit',
        low: 'optional',
      };
      const severity = severityMap[step.priority] ?? 'nit';
      lines.push(
        `    <step id="${step.id}" action="${step.action}" file="${step.file}${loc}" effort="${step.effort.timeLabel}" severity="${severity}">`,
      );
      lines.push(`      <description>${escapeXml(step.description)}</description>`);
      if (step.suggestion) {
        lines.push(`      <suggestion reason="${escapeXml(step.suggestion.reason)}">`);
        if (step.suggestion.before) {
          lines.push(`        <before><![CDATA[${step.suggestion.before}]]></before>`);
        }
        lines.push(`        <after><![CDATA[${step.suggestion.after}]]></after>`);
        // Add type inference context for type-safety issues
        if (step.suggestion.typeContext) {
          const tc = step.suggestion.typeContext;
          lines.push(
            `        <type-inference inferred="${escapeXml(tc.inferredType)}" confidence="${tc.confidence}%">`,
          );
          if (tc.evidence.length > 0) {
            lines.push('          <evidence>');
            for (const e of tc.evidence.slice(0, 5)) {
              const lineAttr = e.line ? ` line="${e.line}"` : '';
              lines.push(
                `            <usage type="${e.type}"${lineAttr}>${escapeXml(e.description)}</usage>`,
              );
            }
            lines.push('          </evidence>');
          }
          lines.push('        </type-inference>');
        }
        lines.push('      </suggestion>');
      }
      // Add code context (snippet + complexity breakdown) for CRITICAL/HIGH
      if (step.codeContext) {
        const codeContextXml = formatCodeContextAsXml(step.codeContext, 6);
        if (codeContextXml) {
          lines.push(codeContextXml);
        }
      }
      lines.push('    </step>');
    }
    lines.push('  </action-plan>');
  }

  // Ranking (dependency hotspots + safe refactoring order)
  if (report.ranking && report.ranking.hotspots.length > 0) {
    lines.push('');
    lines.push('  <!-- RANKING - PageRank-based dependency analysis -->');
    lines.push(
      `  <ranking modules="${report.ranking.stats.nodeCount}" edges="${report.ranking.stats.edgeCount}" cycles="${report.ranking.stats.cycleCount}">`,
    );

    // Hotspots
    lines.push(`    <hotspots count="${report.ranking.hotspots.length}">`);
    for (const hotspot of report.ranking.hotspots.slice(0, 10)) {
      lines.push(
        `      <hotspot path="${escapeXml(hotspot.path)}" percentile="${hotspot.percentile}" risk="${hotspot.risk}">`,
      );
      lines.push(
        `        <metrics pagerank="${hotspot.pageRank.toFixed(4)}" ca="${hotspot.coupling.afferent}" ce="${hotspot.coupling.efferent}" instability="${hotspot.coupling.instability.toFixed(2)}" />`,
      );
      lines.push('      </hotspot>');
    }
    lines.push('    </hotspots>');

    // Safe refactoring order
    if (report.ranking.safeOrder.length > 0) {
      lines.push(`    <safe-order phases="${report.ranking.safeOrder.length}">`);
      for (const phase of report.ranking.safeOrder.slice(0, 5)) {
        const modules = phase.modules.join(', ');
        lines.push(
          `      <phase order="${phase.order}" modules="${phase.modules.length}" risk="${phase.risk}">${modules}</phase>`,
        );
      }
      lines.push('    </safe-order>');
    }

    // Cycles (if any)
    if (report.ranking.cycles.length > 0) {
      lines.push(`    <cycles count="${report.ranking.cycles.length}">`);
      for (const cycle of report.ranking.cycles.slice(0, 3)) {
        lines.push(`      <cycle>${cycle.join(' ‚Üí ')}</cycle>`);
      }
      lines.push('    </cycles>');
    }

    // Leaf/Core nodes
    if (report.ranking.leafNodes.length > 0) {
      lines.push(
        `    <leaf-nodes hint="safe to refactor first">${report.ranking.leafNodes.slice(0, 5).join(', ')}</leaf-nodes>`,
      );
    }
    if (report.ranking.coreNodes.length > 0) {
      lines.push(
        `    <core-nodes hint="refactor last">${report.ranking.coreNodes.join(', ')}</core-nodes>`,
      );
    }

    lines.push('    <hint>Run: krolik refactor for full analysis and migration plan</hint>');
    lines.push('  </ranking>');
  }

  // Backwards-compat shim files (should be deleted)
  if (report.backwardsCompatFiles && report.backwardsCompatFiles.length > 0) {
    lines.push('');
    lines.push('  <!-- BACKWARDS-COMPAT - Deprecated shim files that should be deleted -->');
    lines.push(
      `  <backwards-compat count="${report.backwardsCompatFiles.length}" action="delete">`,
    );
    for (const file of report.backwardsCompatFiles) {
      lines.push(
        `    <shim path="${escapeXml(file.path)}" confidence="${file.confidence}%"${file.movedTo ? ` target="${escapeXml(file.movedTo)}"` : ''}>`,
      );
      lines.push(`      <reason>${escapeXml(file.reason)}</reason>`);
      lines.push(`      <suggestion>${escapeXml(file.suggestion)}</suggestion>`);
      lines.push('    </shim>');
    }
    lines.push('    <hint>Delete these files and update imports to use the new locations</hint>');
    lines.push('  </backwards-compat>');
  }

  // Recommendations (top 10 from refactor analysis)
  if (report.recommendations && report.recommendations.length > 0) {
    lines.push('');
    lines.push('  <!-- RECOMMENDATIONS - Top refactoring priorities -->');
    lines.push(`  <recommendations count="${report.recommendations.length}">`);
    for (const rec of report.recommendations) {
      lines.push(
        `    <rec priority="${rec.priority}" category="${rec.category}" effort="${rec.effort}" auto="${rec.autoFixable}">`,
      );
      lines.push(`      <title>${escapeXml(rec.title)}</title>`);
      lines.push(`      <description>${escapeXml(rec.description)}</description>`);
      if (rec.affectedFiles.length > 0) {
        lines.push(`      <files>${rec.affectedFiles.map((f) => escapeXml(f)).join(', ')}</files>`);
      }
      lines.push('    </rec>');
    }
    lines.push('  </recommendations>');
  }

  // Duplicates summary
  if (report.duplicates && report.duplicates.totalGroups > 0) {
    lines.push('');
    lines.push('  <!-- DUPLICATES - Function duplicates summary -->');
    lines.push(
      `  <duplicates total="${report.duplicates.totalGroups}" merge="${report.duplicates.mergeCount}" rename="${report.duplicates.renameCount}">`,
    );
    for (const dup of report.duplicates.topDuplicates.slice(0, 5)) {
      lines.push(
        `    <dup name="${escapeXml(dup.name)}" similarity="${(dup.similarity * 100).toFixed(0)}%" locations="${dup.locationCount}" action="${dup.recommendation}">`,
      );
      lines.push(`      <files>${dup.files.map((f) => escapeXml(f)).join(', ')}</files>`);
      lines.push('    </dup>');
    }
    lines.push(
      '    <hint>Run: krolik refactor --duplicates-only for full duplicate analysis</hint>',
    );
    lines.push('  </duplicates>');
  }

  // Issue patterns (smart grouping)
  if (report.issuePatterns && report.issuePatterns.length > 0) {
    lines.push('');
    lines.push('  <!-- ISSUE-GROUPS - Pattern-based issue grouping for batch operations -->');
    lines.push(...formatIssuePatterns(report.issuePatterns));
  }

  // Issue clusters (file-level grouping for same-category issues)
  if (report.issueClusters && report.issueClusters.length > 0) {
    lines.push('');
    lines.push(
      '  <!-- ISSUE-CLUSTERS - File-level grouping for related issues (3+ same category) -->',
    );
    lines.push(...formatIssueClusters(report.issueClusters));
  }

  // Readability score (Chromium Tricorder-style)
  if (report.readability) {
    lines.push('');
    lines.push('  <!-- READABILITY - Code readability analysis (Chromium Tricorder-style) -->');
    lines.push(
      `  <readability overall="${report.readability.overall}" grade="${report.readability.grade}">`,
    );
    lines.push(`    <naming>${report.readability.naming}</naming>`);
    lines.push(`    <structure>${report.readability.structure}</structure>`);
    lines.push(`    <comments>${report.readability.comments}</comments>`);
    lines.push(`    <cognitive>${report.readability.cognitive}</cognitive>`);
    if (report.readability.issueCount > 0) {
      lines.push(`    <issue-count>${report.readability.issueCount}</issue-count>`);
    }
    lines.push('  </readability>');
  }

  // Code style recommendations (simplify, typescript, imports, etc.)
  if (report.codeStyleRecommendations && report.codeStyleRecommendations.length > 0) {
    lines.push('');
    lines.push(
      '  <!-- CODE-STYLE - Best practices recommendations (Google/Airbnb style guides) -->',
    );
    lines.push(`  <code-style count="${report.codeStyleRecommendations.length}">`);

    // Group by category
    const byCategory = new Map<string, typeof report.codeStyleRecommendations>();
    for (const rec of report.codeStyleRecommendations) {
      const list = byCategory.get(rec.category) ?? [];
      list.push(rec);
      byCategory.set(rec.category, list);
    }

    for (const [category, recs] of byCategory) {
      lines.push(`    <category name="${category}">`);
      for (const rec of recs) {
        lines.push(`      <rec id="${rec.id}" severity="${rec.severity}" count="${rec.count}">`);
        lines.push(`        <title>${escapeXml(rec.title)}</title>`);
        lines.push(`        <description>${escapeXml(rec.description)}</description>`);
        if (rec.file) {
          const lineAttr = rec.line ? ` line="${rec.line}"` : '';
          const snippetContent = rec.snippet ? escapeXml(rec.snippet) : '';
          if (snippetContent) {
            lines.push(
              `        <example file="${escapeXml(rec.file)}"${lineAttr}>${snippetContent}</example>`,
            );
          } else {
            lines.push(`        <example file="${escapeXml(rec.file)}"${lineAttr} />`);
          }
        }
        // Add before/after fix suggestion if available
        if (rec.fix) {
          lines.push(`        <before>${escapeXml(rec.fix.before)}</before>`);
          lines.push(`        <after>${escapeXml(rec.fix.after)}</after>`);
        }
        lines.push('      </rec>');
      }
      lines.push('    </category>');
    }
    lines.push('  </code-style>');
  }

  lines.push('</ai-report>');

  return lines.join('\n');
}
