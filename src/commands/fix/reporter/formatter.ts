/**
 * @module commands/fix/reporter/formatter
 * @description Formatters for AI Report output
 */

import type {
  AIReport,
  IssueGroup,
  EnrichedIssue,
  ActionStep,
  PriorityLevel,
  FileContext,
} from './types';
import { normalizePath } from './grouping';
import { escapeXml } from '../../../lib';

// ============================================================================
// MARKDOWN FORMATTER
// ============================================================================

/**
 * Format AI Report as Markdown
 */
export function formatAsMarkdown(report: AIReport): string {
  const lines: string[] = [];

  // Header
  lines.push('# AI Code Quality Report');
  lines.push('');
  lines.push(`> Generated by krolik-cli at ${report.meta.generatedAt}`);
  lines.push('');

  // Summary
  lines.push('## Summary');
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Total Issues | ${report.summary.totalIssues} |`);
  lines.push(`| Auto-fixable | ${report.summary.autoFixableIssues} |`);
  lines.push(`| Manual Required | ${report.summary.manualIssues} |`);
  lines.push(`| Total Effort | ${report.summary.totalEffortLabel} |`);
  lines.push('');

  // Priority breakdown
  lines.push('### By Priority');
  lines.push('');
  const priorities: PriorityLevel[] = ['critical', 'high', 'medium', 'low'];
  for (const priority of priorities) {
    const count = report.summary.byPriority[priority];
    if (count > 0) {
      const icon = getPriorityIcon(priority);
      lines.push(`- ${icon} **${priority.toUpperCase()}**: ${count} issues`);
    }
  }
  lines.push('');

  // Context
  if (report.context.techStack && report.context.techStack.length > 0) {
    lines.push('### Tech Stack');
    lines.push('');
    lines.push(report.context.techStack.join(', '));
    lines.push('');
  }

  // AI Rules (CRITICAL - must read first!)
  if (report.aiRules && report.aiRules.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## ‚ö†Ô∏è AI Rules (Read First!)');
    lines.push('');
    lines.push('> **IMPORTANT:** Before starting any work, read these files for project-specific rules and conventions.');
    lines.push('');
    for (const rule of report.aiRules) {
      lines.push(`- \`${rule.path}\` (${rule.scope})`);
    }
    lines.push('');
  }

  // Git Status
  if (report.git) {
    lines.push('---');
    lines.push('');
    lines.push('## Git Status');
    lines.push('');
    lines.push(`- **Branch:** \`${report.git.branch}\``);
    lines.push(`- **Changes:** ${report.git.modified} modified, ${report.git.untracked} untracked, ${report.git.staged} staged`);
    lines.push('');
    if (report.git.recentCommits.length > 0) {
      lines.push('### Recent Commits');
      lines.push('');
      for (const commit of report.git.recentCommits.slice(0, 3)) {
        lines.push(`- \`${commit.hash}\` ${commit.message} *(${commit.relativeDate})*`);
      }
      lines.push('');
    }
  }

  // Next Action
  if (report.nextAction) {
    lines.push('---');
    lines.push('');
    lines.push('## üéØ Next Action');
    lines.push('');
    const priorityIcon = report.nextAction.priority === 'critical' ? 'üî¥' :
      report.nextAction.priority === 'high' ? 'üü†' :
      report.nextAction.priority === 'medium' ? 'üü°' : 'üü¢';
    lines.push(`**${priorityIcon} ${report.nextAction.action}**`);
    if (report.nextAction.reason) {
      lines.push('');
      lines.push(`> ${report.nextAction.reason}`);
    }
    lines.push('');
  }

  // Do-Not Rules
  if (report.doNot && report.doNot.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## üö´ Do Not');
    lines.push('');
    for (const rule of report.doNot) {
      lines.push(`- ${rule}`);
    }
    lines.push('');
  }

  // Quick Wins
  if (report.quickWins.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Quick Wins');
    lines.push('');
    lines.push('These issues can be auto-fixed in seconds:');
    lines.push('');

    for (const win of report.quickWins) {
      const loc = win.issue.line ? `:${win.issue.line}` : '';
      lines.push(`- [ ] \`${win.issue.file}${loc}\` ‚Äî ${win.issue.message} (${win.effort.timeLabel})`);
    }
    lines.push('');
  }

  // Hotspots
  if (report.hotspots.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Hotspot Files');
    lines.push('');
    lines.push('Files with the most issues:');
    lines.push('');
    lines.push('| File | Issues | Priority |');
    lines.push('|------|--------|----------|');

    for (const hotspot of report.hotspots.slice(0, 5)) {
      const icon = getPriorityIcon(hotspot.priority);
      lines.push(`| \`${hotspot.file}\` | ${hotspot.issueCount} | ${icon} ${hotspot.priority} |`);
    }
    lines.push('');
  }

  // Issue Groups
  lines.push('---');
  lines.push('');
  lines.push('## Issues by Priority');
  lines.push('');

  for (const group of report.groups) {
    lines.push(...formatGroup(group));
  }

  // Action Plan
  if (report.actionPlan.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Recommended Action Plan');
    lines.push('');
    lines.push('Execute these steps in order:');
    lines.push('');

    for (const step of report.actionPlan.slice(0, 5)) {
      lines.push(...formatActionStep(step));
    }
  }

  // File Contexts (only files with issues, top 15)
  if (report.fileContexts && report.fileContexts.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## File Contexts');
    lines.push('');
    lines.push('Detailed information about affected files:');
    lines.push('');

    for (const ctx of report.fileContexts) {
      lines.push(...formatFileContext(ctx));
    }
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*Use `krolik fix --ai-execute AI-REPORT.md` to execute this plan automatically.*');
  lines.push('');

  return lines.join('\n');
}

/**
 * Format a single file context
 */
function formatFileContext(ctx: FileContext): string[] {
  const lines: string[] = [];

  lines.push(`### \`${ctx.path}\``);
  lines.push('');
  lines.push(`- **Purpose**: ${ctx.purpose}`);
  lines.push(`- **Type**: ${ctx.type}`);
  lines.push(`- **Metrics**: ${ctx.metrics.lines} lines, ${ctx.metrics.functions} functions, avg complexity ${ctx.metrics.avgComplexity}`);
  lines.push('');

  if (ctx.exports.length > 0) {
    lines.push(`**Exports**: \`${ctx.exports.join('`, `')}\``);
    lines.push('');
  }

  if (ctx.imports.length > 0) {
    lines.push(`**Imports**: ${ctx.imports.map(i => `\`${i}\``).join(', ')}`);
    lines.push('');
  }

  return lines;
}

/**
 * Format a single issue group
 * Shows all CRITICAL/HIGH issues, limits LOW/MEDIUM to 5
 */
function formatGroup(group: IssueGroup): string[] {
  const lines: string[] = [];
  const icon = getPriorityIcon(group.priority);

  lines.push(`### ${icon} ${group.title}`);
  lines.push('');
  lines.push(`> ${group.description}`);
  lines.push(`> **Effort**: ${group.totalEffort.timeLabel} | **Auto-fixable**: ${group.autoFixableCount}/${group.count}`);
  lines.push('');

  // Show all CRITICAL/HIGH, limit LOW/MEDIUM to 5
  const showAll = group.priority === 'critical' || group.priority === 'high';
  const maxIssues = showAll ? group.issues.length : 5;

  for (const enriched of group.issues.slice(0, maxIssues)) {
    lines.push(formatEnrichedIssue(enriched));
  }

  if (group.issues.length > maxIssues) {
    lines.push(`- ... and ${group.issues.length - maxIssues} more issues`);
  }

  lines.push('');
  return lines;
}

/**
 * Format a single enriched issue
 */
function formatEnrichedIssue(enriched: EnrichedIssue): string {
  const { issue, effort, autoFixable } = enriched;
  const file = normalizePath(issue.file);
  const loc = issue.line ? `:${issue.line}` : '';
  const autoTag = autoFixable ? ' [AUTO]' : '';

  return `- [ ] \`${file}${loc}\` ‚Äî ${issue.message} (${effort.timeLabel})${autoTag}`;
}

/**
 * Format an action step
 * CRITICAL issues: inline snippet (need to see immediately)
 * Other issues: collapsible snippet (saves space)
 */
function formatActionStep(step: ActionStep): string[] {
  const lines: string[] = [];
  const file = normalizePath(step.file);
  const loc = step.line ? `:${step.line}` : '';
  const actionIcon = getActionIcon(step.action);
  const priorityIcon = getPriorityIcon(step.priority);

  lines.push(`#### ${step.id}: ${actionIcon} ${step.action.toUpperCase()} ${priorityIcon}`);
  lines.push('');
  lines.push(`**File**: \`${file}${loc}\``);
  lines.push(`**Effort**: ${step.effort.timeLabel}`);
  lines.push('');
  lines.push(`${step.description}`);
  lines.push('');

  // Show code snippet based on priority
  // Use trimEnd() to preserve leading markers (‚Üí) while removing trailing whitespace
  if (step.snippet) {
    const cleanSnippet = step.snippet.trimEnd();
    const snippetLines = cleanSnippet.split('\n').length;

    if (step.priority === 'critical') {
      // CRITICAL: inline snippet (need to see immediately)
      lines.push('**Current code:**');
      lines.push('```typescript');
      lines.push(cleanSnippet);
      lines.push('```');
      lines.push('');
    } else {
      // HIGH/MEDIUM/LOW: collapsible snippet (saves space)
      lines.push('<details>');
      lines.push(`<summary>üìù Show code context (${snippetLines} line${snippetLines > 1 ? 's' : ''})</summary>`);
      lines.push('');
      lines.push('```typescript');
      lines.push(cleanSnippet);
      lines.push('```');
      lines.push('');
      lines.push('</details>');
      lines.push('');
    }
  }

  if (step.suggestion) {
    if (step.priority === 'critical') {
      // CRITICAL: inline suggestion
      lines.push('**Suggested fix:**');
      lines.push('```diff');
      if (step.suggestion.before) {
        lines.push(`- ${step.suggestion.before}`);
      }
      lines.push(`+ ${step.suggestion.after}`);
      lines.push('```');
      lines.push('');
      lines.push(`> ${step.suggestion.reason}`);
      lines.push('');
    } else {
      // Non-critical: collapsible suggestion
      lines.push('<details>');
      lines.push('<summary>üí° Show suggested fix</summary>');
      lines.push('');
      lines.push('```diff');
      if (step.suggestion.before) {
        lines.push(`- ${step.suggestion.before}`);
      }
      lines.push(`+ ${step.suggestion.after}`);
      lines.push('```');
      lines.push('');
      lines.push(`> ${step.suggestion.reason}`);
      lines.push('');
      lines.push('</details>');
      lines.push('');
    }
  }

  return lines;
}

/**
 * Get icon for priority level
 */
function getPriorityIcon(priority: PriorityLevel): string {
  const icons: Record<PriorityLevel, string> = {
    critical: 'üî¥',
    high: 'üü†',
    medium: 'üü°',
    low: 'üü¢',
  };
  return icons[priority];
}

/**
 * Get icon for action type
 */
function getActionIcon(action: ActionStep['action']): string {
  const icons: Record<ActionStep['action'], string> = {
    fix: 'üîß',
    refactor: 'üîÑ',
    review: 'üëÄ',
    skip: '‚è≠Ô∏è',
  };
  return icons[action];
}

// ============================================================================
// JSON FORMATTER
// ============================================================================

/**
 * Format AI Report as JSON
 */
export function formatAsJson(report: AIReport): string {
  return JSON.stringify(report, null, 2);
}

// ============================================================================
// XML FORMATTER
// ============================================================================

/**
 * Format AI Report as XML (AI-friendly format)
 */
export function formatAsXml(report: AIReport): string {
  const lines: string[] = [];

  lines.push('<ai-report>');
  lines.push(`  <meta version="${report.meta.version}" generated="${report.meta.generatedAt}" />`);
  lines.push('');

  // Summary
  lines.push('  <summary>');
  lines.push(`    <total-issues>${report.summary.totalIssues}</total-issues>`);
  lines.push(`    <auto-fixable>${report.summary.autoFixableIssues}</auto-fixable>`);
  lines.push(`    <manual-required>${report.summary.manualIssues}</manual-required>`);
  lines.push(`    <total-effort minutes="${report.summary.totalEffortMinutes}">${report.summary.totalEffortLabel}</total-effort>`);
  lines.push('  </summary>');
  lines.push('');

  // Quick wins
  if (report.quickWins.length > 0) {
    lines.push('  <quick-wins>');
    for (const win of report.quickWins) {
      const loc = win.issue.line ? `:${win.issue.line}` : '';
      lines.push(`    <issue file="${win.issue.file}${loc}" effort="${win.effort.timeLabel}">`);
      lines.push(`      ${escapeXml(win.issue.message)}`);
      lines.push('    </issue>');
    }
    lines.push('  </quick-wins>');
    lines.push('');
  }

  // Action plan
  if (report.actionPlan.length > 0) {
    lines.push('  <action-plan>');
    for (const step of report.actionPlan) {
      const loc = step.line ? `:${step.line}` : '';
      lines.push(`    <step id="${step.id}" action="${step.action}" file="${step.file}${loc}" effort="${step.effort.timeLabel}">`);
      lines.push(`      <description>${escapeXml(step.description)}</description>`);
      if (step.suggestion) {
        lines.push(`      <suggestion reason="${escapeXml(step.suggestion.reason)}">`);
        lines.push(`        ${escapeXml(step.suggestion.after)}`);
        lines.push('      </suggestion>');
      }
      lines.push('    </step>');
    }
    lines.push('  </action-plan>');
  }

  lines.push('</ai-report>');

  return lines.join('\n');
}

