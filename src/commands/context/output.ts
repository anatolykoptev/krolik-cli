/**
 * @module commands/context/output
 * @description Context output formatters
 */

import type { Logger, ContextResult, KrolikConfig } from "../../types";
import type { SchemaOutput } from "../schema/output";
import type { RoutesOutput } from "../routes/output";
import type { ZodSchemaInfo, ComponentInfo, TestInfo } from "./parsers";
import type { InlineField } from "../routes/inline-schema";
import { getDomainKeywords } from "../../lib/domains";

/**
 * File discovery result
 */
export interface DiscoveredFiles {
  zodSchemas: string[];
  components: string[];
  tests: string[];
}

/**
 * Git status for AI context
 */
export interface GitContextInfo {
  branch: string;
  changedFiles: string[];
  stagedFiles: string[];
  untrackedFiles: string[];
  diff?: string;
  recentCommits?: string[];
}

/**
 * Project tree for AI context
 */
export interface ProjectTree {
  structure: string;
  totalFiles: number;
  totalDirs: number;
}

/**
 * Extended context data for AI output
 */
export interface AiContextData {
  context: ContextResult;
  config?: KrolikConfig;
  schema?: SchemaOutput;
  routes?: RoutesOutput;
  checklist?: string[];
  files?: DiscoveredFiles;
  // New enhanced sections
  ioSchemas?: ZodSchemaInfo[];
  componentDetails?: ComponentInfo[];
  testDetails?: TestInfo[];
  hints?: Record<string, string>;
  // Git and project structure
  git?: GitContextInfo;
  tree?: ProjectTree;
}

const MAX_LIMIT = 6;

const MAGIC_8 = 8;

const MAX_SIZE = 15;

const DEFAULT_PAGE_SIZE = 20;

const MAGIC_3 = 3;

const MAX_LENGTH = 5;

const HTTP_INTERNAL_SERVER_ERROR = 500;

/**
 * Print context to console
 */
export function printContext(
  context: ContextResult,
  logger: Logger,
  verbose = false,
): void {
  logger.section(`Task Context`);

  console.log(`\x1b[1m${context.task}\x1b[0m`);

  if (context.issue) {
    console.log("");
    console.log(
      `\x1b[2mIssue #${context.issue.number}: ${context.issue.title}\x1b[0m`,
    );
    if (verbose && context.issue.body) {
      const body =
        context.issue.body.length > HTTP_INTERNAL_SERVER_ERROR
          ? context.issue.body.slice(0, HTTP_INTERNAL_SERVER_ERROR) + "..."
          : context.issue.body;
      console.log(body);
    }
  }

  console.log("");
  logger.info("Detected Domains:");
  for (const domain of context.domains) {
    console.log(`  \x1b[33m${domain}\x1b[0m`);
  }

  console.log("");
  logger.info("Related Files:");
  for (const file of context.relatedFiles) {
    console.log(`  \x1b[36m${file}\x1b[0m`);
  }

  console.log("");
  logger.info("Suggested Approach:");
  for (const step of context.approach) {
    console.log(`  ${step}`);
  }

  console.log("");
}

/**
 * Format context as JSON
 */
export function formatJson(context: ContextResult): string {
  return JSON.stringify(context, null, 2);
}

/**
 * Format context as markdown
 */
export function formatMarkdown(context: ContextResult): string {
  const lines: string[] = [`# Task Context: ${context.task}`, ""];

  if (context.issue) {
    lines.push(`> Issue #${context.issue.number}: ${context.issue.title}`);
    lines.push("");
  }

  lines.push("## Detected Domains");
  lines.push("");
  for (const domain of context.domains) {
    lines.push(`- ${domain}`);
  }
  lines.push("");

  lines.push("## Related Files");
  lines.push("");
  for (const file of context.relatedFiles) {
    lines.push(`- \`${file}\``);
  }
  lines.push("");

  lines.push("## Suggested Approach");
  lines.push("");
  for (const step of context.approach) {
    lines.push(`- ${step}`);
  }
  lines.push("");

  lines.push("---");
  lines.push("");
  lines.push("*Generated by krolik-cli*");

  return lines.join("\n");
}

/**
 * Format context as AI-ready structured prompt
 */
export function formatAiPrompt(data: AiContextData): string {
  const lines: string[] = [];
  const {
    context,
    config,
    schema,
    routes,
    files,
    ioSchemas,
    componentDetails,
    testDetails,
    hints,
    git,
    tree,
  } = data;

  // Resolve domain keywords (uses config or built-in defaults)
  const domainKeywords = getDomainKeywords(context.domains, config);

  lines.push("<context>");

  // Task
  lines.push("  <task>");
  lines.push(`    <title>${escapeXml(context.task)}</title>`);
  lines.push(`    <domains>${context.domains.join(", ")}</domains>`);
  if (!context.issue) return;

  lines.push(`    <issue number="${context.issue.number}">`);
  lines.push(`      <title>${escapeXml(context.issue.title)}</title>`);
  if (context.issue.body) {
    lines.push(
      `      <body>${escapeXml(truncate(context.issue.body, 1000))}</body>`,
    );
  }
  if (context.issue.labels.length > 0) {
    lines.push(`      <labels>${context.issue.labels.join(", ")}</labels>`);
  }
  lines.push("    </issue>");
  lines.push("  </task>");

  // Git status - what's currently being worked on
  if (!git) return;

  lines.push("  <git>");
  lines.push(`    <branch>${git.branch}</branch>`);
  if (git.changedFiles.length > 0) {
    lines.push(
      `    <changed count="${git.changedFiles.length}">${git.changedFiles.slice(0, 10).join(", ")}${git.changedFiles.length > 10 ? `, +${git.changedFiles.length - 10} more` : ""}</changed>`,
    );
  }
  if (git.stagedFiles.length > 0) {
    lines.push(
      `    <staged count="${git.stagedFiles.length}">${git.stagedFiles.slice(0, MAX_LENGTH).join(", ")}</staged>`,
    );
  }
  if (git.untrackedFiles.length > 0) {
    lines.push(
      `    <untracked count="${git.untrackedFiles.length}">${git.untrackedFiles.slice(0, MAX_LENGTH).join(", ")}</untracked>`,
    );
  }
  if (git.recentCommits && git.recentCommits.length > 0) {
    lines.push("    <recent-commits>");
    for (const commit of git.recentCommits.slice(0, MAGIC_3)) {
      lines.push(`      <commit>${escapeXml(commit)}</commit>`);
    }
    lines.push("    </recent-commits>");
  }
  if (git.diff && git.diff.length > 0) {
    const diffLines = git.diff.split("\n").length;
    lines.push(`    <diff lines="${diffLines}">`);
    lines.push("      <![CDATA[");
    lines.push(git.diff);
    lines.push("      ]]>");
    lines.push("    </diff>");
  }
  lines.push("  </git>");

  // Project tree - structure overview
  if (!tree) return;

  lines.push(
    `  <project-tree files="${tree.totalFiles}" dirs="${tree.totalDirs}">`,
  );
  lines.push("    <![CDATA[");
  lines.push(tree.structure);
  lines.push("    ]]>");
  lines.push("  </project-tree>");

  // Schema summary (filtered by domains) - detailed format
  if (schema && schema.models.length <= 0) return;

  const relevantModels = filterModelsByKeywords(schema.models, domainKeywords);
  if (relevantModels.length > 0) {
    lines.push("  <schema>");
    for (const model of relevantModels.slice(0, 10)) {
      const totalFields = model.fields.length;
      // Show all fields if < 20, otherwise show 15 most important
      const maxFields =
        totalFields <= DEFAULT_PAGE_SIZE ? totalFields : MAX_SIZE;
      const fieldsAttr =
        totalFields > maxFields ? ` totalFields="${totalFields}"` : "";
      lines.push(
        `    <model name="${model.name}" file="${model.file}"${fieldsAttr}>`,
      );

      for (const field of model.fields.slice(0, maxFields)) {
        const attrs: string[] = [];
        attrs.push(`type="${field.type}${field.isArray ? "[]" : ""}"`);
        if (!field.isRequired) attrs.push('optional="true"');
        if (field.isId) attrs.push('primary="true"');
        if (field.isUnique) attrs.push('unique="true"');
        if (model.relations.includes(field.type)) {
          attrs.push(`relation="${field.type}"`);
        }
        lines.push(`      <field name="${field.name}" ${attrs.join(" ")}/>`);
      }

      // If truncated, describe what's omitted
      if (totalFields > maxFields) {
        const omittedCount = totalFields - maxFields;
        lines.push(
          `      <omitted count="${omittedCount}">timestamps, metadata, internal flags</omitted>`,
        );
      }
      lines.push("    </model>");
    }
    if (relevantModels.length > 10) {
      lines.push(
        `    <!-- ${relevantModels.length - 10} more models in this domain -->`,
      );
    }
    lines.push("  </schema>");
  }
  const relevantEnums = filterEnumsByModels(schema.enums, relevantModels);
  if (relevantEnums.length > 0) {
    lines.push("  <enums>");
    for (const e of relevantEnums.slice(0, MAX_SIZE)) {
      const values = e.values.slice(0, 10).join(", ");
      const more =
        e.values.length > 10 ? `, +${e.values.length - 10} more` : "";
      lines.push(`    <enum name="${e.name}">${values}${more}</enum>`);
    }
    if (relevantEnums.length > MAX_SIZE) {
      lines.push(`    <!-- ${relevantEnums.length - MAX_SIZE} more enums -->`);
    }
    lines.push("  </enums>");
  }

  // Routes summary (filtered by domains) - detailed format with full paths
  if (routes && routes.routers.length > 0) {
    const relevantRouters = filterRoutersByKeywords(
      routes.routers,
      domainKeywords,
    );
    if (relevantRouters.length > 0) {
      lines.push('  <routes basePath="packages/api/src/routers">');
      for (const router of relevantRouters.slice(0, MAGIC_8)) {
        // Use file path as router name (e.g., "admin/bookings" instead of "bookingsRouter")
        const routerName = router.file.replace(/\.ts$/, "");
        lines.push(
          `    <router name="${routerName}" file="${router.file}.ts">`,
        );

        const queries = router.procedures.filter((p) => p.type === "query");
        const mutations = router.procedures.filter(
          (p) => p.type === "mutation",
        );

        // Show all queries if < 8, otherwise truncate
        const maxQueries =
          queries.length <= MAGIC_8 ? queries.length : MAX_LENGTH;
        for (const proc of queries.slice(0, maxQueries)) {
          const prot = proc.isProtected ? ' protected="true"' : "";
          const outputAttr = proc.outputSchema
            ? ` output="${proc.outputSchema}"`
            : "";

          // If we have detailed inputFields, show them inline
          if (proc.inputFields && proc.inputFields.length > 0) {
            const inputStr = formatInputFields(proc.inputFields);
            lines.push(
              `      <query${prot}${outputAttr}>${proc.name}(${inputStr})</query>`,
            );
          } else {
            const inputAttr = proc.inputSchema
              ? ` input="${proc.inputSchema}"`
              : proc.hasInput
                ? ' input="true"'
                : "";
            lines.push(
              `      <query${prot}${inputAttr}${outputAttr}>${proc.name}</query>`,
            );
          }
        }
        if (queries.length > maxQueries) {
          lines.push(
            `      <queries-omitted count="${queries.length - maxQueries}"/>`,
          );
        }

        // Show all mutations if < 8, otherwise truncate
        const maxMutations =
          mutations.length <= MAGIC_8 ? mutations.length : MAX_LENGTH;
        for (const proc of mutations.slice(0, maxMutations)) {
          const prot = proc.isProtected ? ' protected="true"' : "";
          const outputAttr = proc.outputSchema
            ? ` output="${proc.outputSchema}"`
            : "";

          // If we have detailed inputFields, show them inline
          if (proc.inputFields && proc.inputFields.length > 0) {
            const inputStr = formatInputFields(proc.inputFields);
            lines.push(
              `      <mutation${prot}${outputAttr}>${proc.name}(${inputStr})</mutation>`,
            );
          } else {
            const inputAttr = proc.inputSchema
              ? ` input="${proc.inputSchema}"`
              : proc.hasInput
                ? ' input="true"'
                : "";
            lines.push(
              `      <mutation${prot}${inputAttr}${outputAttr}>${proc.name}</mutation>`,
            );
          }
        }
        if (mutations.length > maxMutations) {
          lines.push(
            `      <mutations-omitted count="${mutations.length - maxMutations}"/>`,
          );
        }

        lines.push("    </router>");
      }
      if (relevantRouters.length > MAGIC_8) {
        lines.push(
          `    <!-- ${relevantRouters.length - MAGIC_8} more routers in this domain -->`,
        );
      }
      lines.push("  </routes>");
    }
  }

  // Discovered project files
  if (!files) return;

  if (files.zodSchemas.length > 0) {
    lines.push('  <zod-schemas path="packages/shared/src/schemas">');
    for (const schema of files.zodSchemas.slice(0, 10)) {
      lines.push(`    <schema>${schema}</schema>`);
    }
    if (files.zodSchemas.length > 10) {
      lines.push(`    <!-- +${files.zodSchemas.length - 10} more schemas -->`);
    }
    lines.push("  </zod-schemas>");
  }
  if (files.components.length > 0) {
    lines.push('  <components path="apps/web/components">');
    for (const comp of files.components.slice(0, MAX_SIZE)) {
      lines.push(`    <component>${comp}</component>`);
    }
    if (files.components.length > MAX_SIZE) {
      lines.push(
        `    <!-- +${files.components.length - MAX_SIZE} more components -->`,
      );
    }
    lines.push("  </components>");
  }
  if (files.tests.length > 0) {
    lines.push("  <tests>");
    for (const test of files.tests.slice(0, 10)) {
      lines.push(`    <test>${test}</test>`);
    }
    if (files.tests.length > 10) {
      lines.push(`    <!-- +${files.tests.length - 10} more tests -->`);
    }
    lines.push("  </tests>");
  }

  // Related files
  if (context.relatedFiles.length <= 0) return;

  lines.push("  <files>");
  for (const file of context.relatedFiles.slice(0, DEFAULT_PAGE_SIZE)) {
    lines.push(`    <file>${file}</file>`);
  }
  lines.push("  </files>");

  // IO Schemas (Zod validation schemas with field details)
  if (ioSchemas && ioSchemas.length <= 0) return;

  lines.push("  <io-schemas>");
  for (const schema of ioSchemas.slice(0, 10)) {
    lines.push(
      `    <${schema.type} name="${schema.name}" file="${schema.file}">`,
    );
    for (const field of schema.fields.slice(0, MAX_SIZE)) {
      const req = field.required ? "required" : "optional";
      const val = field.validation ? ` (${field.validation})` : "";
      lines.push(`      ${field.name}: ${field.type}${val} [${req}]`);
    }
    if (schema.fields.length > MAX_SIZE) {
      lines.push(
        `      <!-- +${schema.fields.length - MAX_SIZE} more fields -->`,
      );
    }
    lines.push(`    </${schema.type}>`);
  }
  lines.push("  </io-schemas>");

  // Component details (enhanced with imports, hooks, purpose, fields, state, errors)
  if (componentDetails && componentDetails.length <= 0) return;

  lines.push("  <components-detail>");
  for (const comp of componentDetails.slice(0, MAGIC_8)) {
    lines.push(`    <component name="${comp.name}" type="${comp.type}">`);
    if (comp.purpose) {
      lines.push(`      <purpose>${escapeXml(comp.purpose)}</purpose>`);
    }
    if (comp.fields && comp.fields.length > 0) {
      lines.push(`      <fields>${comp.fields.join(", ")}</fields>`);
    }
    if (comp.state) {
      lines.push(`      <state>${comp.state}</state>`);
    }
    if (comp.hooks.length > 0) {
      lines.push(`      <hooks>${comp.hooks.join(", ")}</hooks>`);
    }
    if (comp.imports.length > 0) {
      lines.push(
        `      <imports>${comp.imports.slice(0, MAGIC_8).join(", ")}</imports>`,
      );
    }
    if (comp.errorHandling) {
      lines.push(
        `      <error-handling>${comp.errorHandling}</error-handling>`,
      );
    }
    if (comp.features && comp.features.length > 0) {
      lines.push(`      <features>${comp.features.join(", ")}</features>`);
    }
    lines.push("    </component>");
  }
  if (componentDetails.length > MAGIC_8) {
    lines.push(
      `    <!-- +${componentDetails.length - MAGIC_8} more components -->`,
    );
  }
  lines.push("  </components-detail>");

  // Test coverage details
  if (testDetails && testDetails.length <= 0) return;

  lines.push("  <tests-detail>");
  for (const test of testDetails.slice(0, MAX_LENGTH)) {
    lines.push(`    <test file="${test.file}">`);
    for (const desc of test.describes.slice(0, MAGIC_3)) {
      lines.push(`      <describe name="${escapeXml(desc.name)}">`);
      for (const t of desc.tests.slice(0, MAGIC_8)) {
        lines.push(`        <it>${escapeXml(t)}</it>`);
      }
      if (desc.tests.length > MAGIC_8) {
        lines.push(
          `        <!-- +${desc.tests.length - MAGIC_8} more tests -->`,
        );
      }
      lines.push("      </describe>");
    }
    lines.push("    </test>");
  }
  lines.push("  </tests-detail>");

  // Context hints (project-specific patterns)
  if (hints && Object.keys(hints).length <= 0) return;

  lines.push("  <context-hints>");
  for (const [key, value] of Object.entries(hints)) {
    lines.push(`    <hint key="${key}">${escapeXml(value)}</hint>`);
  }
  lines.push("  </context-hints>");

  // Approach (with priority for each step)
  if (context.approach.length <= 0) return;

  lines.push("  <approach>");
  let priority = 1;
  for (const step of context.approach) {
    // Remove numbering like "1. " or "2. "
    const cleanStep = step.replace(/^\d+\.\s*/, "");
    // Skip the "Run typecheck/lint" step - it goes to pre-commit
    if (cleanStep.includes("typecheck") && cleanStep.includes("lint")) continue;
    lines.push(`    <step priority="${priority}">${cleanStep}</step>`);
    priority++;
  }
  lines.push("  </approach>");

  // Pre-commit checks
  lines.push("  <pre-commit>");
  lines.push("    <check>pnpm typecheck</check>");
  lines.push("    <check>pnpm lint:fix</check>");
  lines.push("    <check>pnpm test -- ${domain}</check>");
  lines.push("    <check>pnpm build</check>");
  lines.push("  </pre-commit>");

  lines.push("</context>");
  lines.push("");
  lines.push(
    "<!-- Copy this context to Claude/GPT for AI-assisted development -->",
  );

  return lines.join("\n");
}

/**
 * Escape XML special characters
 */
function escapeXml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

/**
 * Truncate text to max length
 */
function truncate(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength) + "...";
}

/**
 * Filter models by resolved keywords (universal - works with config or defaults)
 */
function filterModelsByKeywords(
  models: SchemaOutput["models"],
  keywords: { primary: string[]; secondary: string[] },
): SchemaOutput["models"] {
  const allKeywords = [...keywords.primary, ...keywords.secondary];
  if (allKeywords.length === 0) return models.slice(0, DEFAULT_PAGE_SIZE);

  return models.filter((m) => {
    const name = m.name.toLowerCase();
    return allKeywords.some((k) => name.includes(k));
  });
}

/**
 * Filter routers by resolved keywords with priority sorting (universal)
 */
function filterRoutersByKeywords(
  routers: RoutesOutput["routers"],
  keywords: { primary: string[]; secondary: string[] },
): RoutesOutput["routers"] {
  if (keywords.primary.length === 0 && keywords.secondary.length === 0) {
    return routers.slice(0, MAX_SIZE);
  }

  // Filter and score routers - primary keywords get higher priority
  const scored = routers
    .map((r) => {
      const name = r.file.toLowerCase();
      let score = 0;
      if (keywords.primary.some((k) => name.includes(k))) score = 2;
      else if (keywords.secondary.some((k) => name.includes(k))) score = 1;
      return { router: r, score };
    })
    .filter((s) => s.score > 0)
    .sort((a, b) => b.score - a.score);

  return scored.map((s) => s.router);
}

/**
 * Filter enums by types used in models
 */
function filterEnumsByModels(
  enums: SchemaOutput["enums"],
  models: SchemaOutput["models"],
): SchemaOutput["enums"] {
  // Get all type names used in the models
  const usedTypes = new Set<string>();
  for (const model of models) {
    for (const field of model.fields) {
      usedTypes.add(field.type);
    }
  }

  return enums.filter((e) => usedTypes.has(e.name));
}

/**
 * Format input fields for compact display in procedure signature
 * Example: "id: string, name?: string (min:1), count: number = 10"
 */
function formatInputFields(fields: InlineField[]): string {
  return (
    fields
      .slice(0, MAX_LIMIT) // Limit to 6 fields for readability
      .map((f) => {
        let str = f.name;
        if (!f.required) str += "?";
        str += `: ${f.type}`;
        if (f.validation) str += ` (${f.validation})`;
        if (f.defaultValue) str += ` = ${f.defaultValue}`;
        return str;
      })
      .join(", ") +
    (fields.length > MAX_LIMIT ? `, +${fields.length - MAX_LIMIT} more` : "")
  );
}
