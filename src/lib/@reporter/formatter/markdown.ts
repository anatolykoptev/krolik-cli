/**
 * @module lib/@reporter/formatter/markdown
 * @description Markdown formatter for AI Report
 */

import { normalizePath } from '../grouping';
import type {
  ActionStep,
  AIReport,
  EnrichedIssue,
  FileContext,
  IssueGroup,
  PriorityLevel,
} from '../types';
import { getActionIcon, getPriorityIcon } from './shared';

// ============================================================================
// MARKDOWN FORMATTER
// ============================================================================

/**
 * Format AI Report as Markdown
 */
export function formatAsMarkdown(report: AIReport): string {
  const lines: string[] = [];

  // Header
  lines.push('# AI Code Quality Report');
  lines.push('');
  lines.push(`> Generated by krolik-cli at ${report.meta.generatedAt}`);
  lines.push('');

  // Summary
  lines.push(...formatMarkdownSummary(report));

  // Context
  lines.push(...formatMarkdownContext(report));

  // AI Rules
  lines.push(...formatMarkdownAiRules(report));

  // Git Status
  lines.push(...formatMarkdownGit(report));

  // Next Action
  lines.push(...formatMarkdownNextAction(report));

  // Do-Not Rules
  lines.push(...formatMarkdownDoNot(report));

  // Quick Wins
  lines.push(...formatMarkdownQuickWins(report));

  // Hotspots
  lines.push(...formatMarkdownHotspots(report));

  // Issue Groups
  lines.push('---');
  lines.push('');
  lines.push('## Issues by Priority');
  lines.push('');

  for (const group of report.groups) {
    lines.push(...formatGroup(group));
  }

  // Action Plan
  lines.push(...formatMarkdownActionPlan(report));

  // File Contexts
  lines.push(...formatMarkdownFileContexts(report));

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*Use `krolik fix --ai-execute AI-REPORT.md` to execute this plan automatically.*');
  lines.push('');

  return lines.join('\n');
}

// ============================================================================
// MARKDOWN SECTION HELPERS
// ============================================================================

function formatMarkdownSummary(report: AIReport): string[] {
  const lines: string[] = [];

  lines.push('## Summary');
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Total Issues | ${report.summary.totalIssues} |`);
  lines.push(`| Auto-fixable | ${report.summary.autoFixableIssues} |`);
  lines.push(`| Manual Required | ${report.summary.manualIssues} |`);
  lines.push(`| Total Effort | ${report.summary.totalEffortLabel} |`);
  lines.push('');

  // Priority breakdown
  lines.push('### By Priority');
  lines.push('');
  const priorities: PriorityLevel[] = ['critical', 'high', 'medium', 'low'];
  for (const priority of priorities) {
    const count = report.summary.byPriority[priority];
    if (count > 0) {
      const icon = getPriorityIcon(priority);
      lines.push(`- ${icon} **${priority.toUpperCase()}**: ${count} issues`);
    }
  }
  lines.push('');

  return lines;
}

function formatMarkdownContext(report: AIReport): string[] {
  if (!report.context.techStack || report.context.techStack.length === 0) {
    return [];
  }

  return ['### Tech Stack', '', report.context.techStack.join(', '), ''];
}

function formatMarkdownAiRules(report: AIReport): string[] {
  if (!report.aiRules || report.aiRules.length === 0) {
    return [];
  }

  const lines: string[] = [];
  lines.push('---');
  lines.push('');
  lines.push('## âš ï¸ AI Rules (Read First!)');
  lines.push('');
  lines.push(
    '> **IMPORTANT:** Before starting any work, read these files for project-specific rules and conventions.',
  );
  lines.push('');
  for (const rule of report.aiRules) {
    lines.push(`- \`${rule.path}\` (${rule.scope})`);
  }
  lines.push('');

  return lines;
}

function formatMarkdownGit(report: AIReport): string[] {
  if (!report.git) return [];

  const lines: string[] = [];
  lines.push('---');
  lines.push('');
  lines.push('## Git Status');
  lines.push('');
  lines.push(`- **Branch:** \`${report.git.branch}\``);
  lines.push(
    `- **Changes:** ${report.git.modified} modified, ${report.git.untracked} untracked, ${report.git.staged} staged`,
  );
  lines.push('');
  if (report.git.recentCommits.length > 0) {
    lines.push('### Recent Commits');
    lines.push('');
    for (const commit of report.git.recentCommits.slice(0, 3)) {
      lines.push(`- \`${commit.hash}\` ${commit.message} *(${commit.relativeDate})*`);
    }
    lines.push('');
  }

  return lines;
}

function formatMarkdownNextAction(report: AIReport): string[] {
  if (!report.nextAction) return [];

  const lines: string[] = [];
  lines.push('---');
  lines.push('');
  lines.push('## ðŸŽ¯ Next Action');
  lines.push('');
  const priorityIcon =
    report.nextAction.priority === 'critical'
      ? 'ðŸ”´'
      : report.nextAction.priority === 'high'
        ? 'ðŸŸ '
        : report.nextAction.priority === 'medium'
          ? 'ðŸŸ¡'
          : 'ðŸŸ¢';
  lines.push(`**${priorityIcon} ${report.nextAction.action}**`);
  if (report.nextAction.reason) {
    lines.push('');
    lines.push(`> ${report.nextAction.reason}`);
  }
  lines.push('');

  return lines;
}

function formatMarkdownDoNot(report: AIReport): string[] {
  if (!report.doNot || report.doNot.length === 0) return [];

  const lines: string[] = [];
  lines.push('---');
  lines.push('');
  lines.push('## ðŸš« Do Not');
  lines.push('');
  for (const rule of report.doNot) {
    lines.push(`- ${rule}`);
  }
  lines.push('');

  return lines;
}

function formatMarkdownQuickWins(report: AIReport): string[] {
  if (report.quickWins.length === 0) return [];

  const lines: string[] = [];
  lines.push('---');
  lines.push('');
  lines.push('## Quick Wins');
  lines.push('');
  lines.push('These issues can be auto-fixed in seconds:');
  lines.push('');

  for (const win of report.quickWins) {
    const loc = win.issue.line ? `:${win.issue.line}` : '';
    lines.push(
      `- [ ] \`${win.issue.file}${loc}\` â€” ${win.issue.message} (${win.effort.timeLabel})`,
    );
  }
  lines.push('');

  return lines;
}

function formatMarkdownHotspots(report: AIReport): string[] {
  if (report.hotspots.length === 0) return [];

  const lines: string[] = [];
  lines.push('---');
  lines.push('');
  lines.push('## Hotspot Files');
  lines.push('');
  lines.push('Files with the most issues:');
  lines.push('');
  lines.push('| File | Issues | Priority |');
  lines.push('|------|--------|----------|');

  for (const hotspot of report.hotspots.slice(0, 5)) {
    const icon = getPriorityIcon(hotspot.priority);
    lines.push(`| \`${hotspot.file}\` | ${hotspot.issueCount} | ${icon} ${hotspot.priority} |`);
  }
  lines.push('');

  return lines;
}

function formatMarkdownActionPlan(report: AIReport): string[] {
  if (report.actionPlan.length === 0) return [];

  const lines: string[] = [];
  lines.push('---');
  lines.push('');
  lines.push('## Recommended Action Plan');
  lines.push('');
  lines.push('Execute these steps in order:');
  lines.push('');

  for (const step of report.actionPlan.slice(0, 5)) {
    lines.push(...formatActionStep(step));
  }

  return lines;
}

function formatMarkdownFileContexts(report: AIReport): string[] {
  if (!report.fileContexts || report.fileContexts.length === 0) return [];

  const lines: string[] = [];
  lines.push('---');
  lines.push('');
  lines.push('## File Contexts');
  lines.push('');
  lines.push('Detailed information about affected files:');
  lines.push('');

  for (const ctx of report.fileContexts) {
    lines.push(...formatFileContext(ctx));
  }

  return lines;
}

// ============================================================================
// ISSUE FORMATTERS
// ============================================================================

/**
 * Format a single file context
 */
function formatFileContext(ctx: FileContext): string[] {
  const lines: string[] = [];

  lines.push(`### \`${ctx.path}\``);
  lines.push('');
  lines.push(`- **Purpose**: ${ctx.purpose}`);
  lines.push(`- **Type**: ${ctx.type}`);
  lines.push(
    `- **Metrics**: ${ctx.metrics.lines} lines, ${ctx.metrics.functions} functions, avg complexity ${ctx.metrics.avgComplexity}`,
  );
  lines.push('');

  if (ctx.exports.length > 0) {
    lines.push(`**Exports**: \`${ctx.exports.join('`, `')}\``);
    lines.push('');
  }

  if (ctx.imports.length > 0) {
    lines.push(`**Imports**: ${ctx.imports.map((i) => `\`${i}\``).join(', ')}`);
    lines.push('');
  }

  return lines;
}

/**
 * Format a single issue group
 */
function formatGroup(group: IssueGroup): string[] {
  const lines: string[] = [];
  const icon = getPriorityIcon(group.priority);

  lines.push(`### ${icon} ${group.title}`);
  lines.push('');
  lines.push(`> ${group.description}`);
  lines.push(
    `> **Effort**: ${group.totalEffort.timeLabel} | **Auto-fixable**: ${group.autoFixableCount}/${group.count}`,
  );
  lines.push('');

  const showAll = group.priority === 'critical' || group.priority === 'high';
  const maxIssues = showAll ? group.issues.length : 5;

  for (const enriched of group.issues.slice(0, maxIssues)) {
    lines.push(formatEnrichedIssue(enriched));
  }

  if (group.issues.length > maxIssues) {
    lines.push(`- ... and ${group.issues.length - maxIssues} more issues`);
  }

  lines.push('');
  return lines;
}

/**
 * Format a single enriched issue
 */
function formatEnrichedIssue(enriched: EnrichedIssue): string {
  const { issue, effort, autoFixable } = enriched;
  const file = normalizePath(issue.file);
  const loc = issue.line ? `:${issue.line}` : '';
  const autoTag = autoFixable ? ' [AUTO]' : '';

  return `- [ ] \`${file}${loc}\` â€” ${issue.message} (${effort.timeLabel})${autoTag}`;
}

/**
 * Format an action step
 */
function formatActionStep(step: ActionStep): string[] {
  const lines: string[] = [];
  const file = normalizePath(step.file);
  const loc = step.line ? `:${step.line}` : '';
  const actionIcon = getActionIcon(step.action);
  const priorityIcon = getPriorityIcon(step.priority);

  lines.push(`#### ${step.id}: ${actionIcon} ${step.action.toUpperCase()} ${priorityIcon}`);
  lines.push('');
  lines.push(`**File**: \`${file}${loc}\``);
  lines.push(`**Effort**: ${step.effort.timeLabel}`);
  lines.push('');
  lines.push(`${step.description}`);
  lines.push('');

  if (step.snippet) {
    const cleanSnippet = step.snippet.trimEnd();
    const snippetLines = cleanSnippet.split('\n').length;

    if (step.priority === 'critical') {
      lines.push('**Current code:**');
      lines.push('```typescript');
      lines.push(cleanSnippet);
      lines.push('```');
      lines.push('');
    } else {
      lines.push('<details>');
      lines.push(
        `<summary>ðŸ“ Show code context (${snippetLines} line${snippetLines > 1 ? 's' : ''})</summary>`,
      );
      lines.push('');
      lines.push('```typescript');
      lines.push(cleanSnippet);
      lines.push('```');
      lines.push('');
      lines.push('</details>');
      lines.push('');
    }
  }

  if (step.suggestion) {
    if (step.priority === 'critical') {
      lines.push('**Suggested fix:**');
      lines.push('```diff');
      if (step.suggestion.before) {
        lines.push(`- ${step.suggestion.before}`);
      }
      lines.push(`+ ${step.suggestion.after}`);
      lines.push('```');
      lines.push('');
      lines.push(`> ${step.suggestion.reason}`);
      lines.push('');
    } else {
      lines.push('<details>');
      lines.push('<summary>ðŸ’¡ Show suggested fix</summary>');
      lines.push('');
      lines.push('```diff');
      if (step.suggestion.before) {
        lines.push(`- ${step.suggestion.before}`);
      }
      lines.push(`+ ${step.suggestion.after}`);
      lines.push('```');
      lines.push('');
      lines.push(`> ${step.suggestion.reason}`);
      lines.push('');
      lines.push('</details>');
      lines.push('');
    }
  }

  return lines;
}
