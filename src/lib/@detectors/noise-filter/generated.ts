/**
 * @module lib/@detectors/noise-filter/generated
 * @description Stage 1: Generated File Detector
 *
 * Confidence-based detection of generated files using multiple signals:
 * - Header markers (@generated, DO NOT EDIT, etc.)
 * - Tool signatures (Prisma Client, graphql-codegen, etc.)
 * - Path patterns (/generated/, /__generated__/, etc.)
 *
 * Uses LRU cache for performance optimization.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import type { GeneratedFileResult, GeneratedSignal } from './types';

// ============================================================================
// CONSTANTS
// ============================================================================

/** Maximum lines to read for header detection (performance) */
const HEADER_LINES_LIMIT = 50;

/** LRU cache size for detection results */
const CACHE_MAX_SIZE = 500;

/** Default confidence threshold for isGeneratedFile() */
const DEFAULT_THRESHOLD = 0.7;

// ============================================================================
// SIGNAL DEFINITIONS
// ============================================================================

/** Header marker patterns with confidence weights */
const HEADER_PATTERNS: ReadonlyArray<{ pattern: RegExp; weight: number; name: string }> = [
  {
    pattern: /This file was automatically generated/i,
    weight: 0.95,
    name: 'auto-generated-comment',
  },
  { pattern: /@generated/i, weight: 0.9, name: '@generated' },
  { pattern: /DO NOT EDIT/i, weight: 0.8, name: 'DO NOT EDIT' },
  { pattern: /AUTO[-_]?GENERATED/i, weight: 0.8, name: 'AUTO-GENERATED' },
  { pattern: /Generated by/i, weight: 0.85, name: 'Generated by' },
  { pattern: /This file is auto-generated/i, weight: 0.9, name: 'auto-generated-notice' },
  { pattern: /DO NOT MODIFY/i, weight: 0.75, name: 'DO NOT MODIFY' },
  { pattern: /Machine generated/i, weight: 0.85, name: 'machine-generated' },
];

/** Tool signature patterns with confidence weights */
const TOOL_PATTERNS: ReadonlyArray<{ pattern: RegExp; weight: number; generator: string }> = [
  { pattern: /Prisma Client/i, weight: 0.99, generator: 'prisma' },
  { pattern: /@prisma\/client/i, weight: 0.99, generator: 'prisma' },
  { pattern: /graphql-codegen/i, weight: 0.95, generator: 'graphql-codegen' },
  { pattern: /openapi-generator/i, weight: 0.95, generator: 'openapi-generator' },
  { pattern: /swagger-codegen/i, weight: 0.95, generator: 'swagger-codegen' },
  { pattern: /protobuf/i, weight: 0.9, generator: 'protobuf' },
  { pattern: /grpc-tools/i, weight: 0.9, generator: 'grpc' },
  { pattern: /TypeGraphQL/i, weight: 0.85, generator: 'typegraphql' },
  { pattern: /drizzle-orm/i, weight: 0.8, generator: 'drizzle' },
  { pattern: /kysely-codegen/i, weight: 0.9, generator: 'kysely' },
];

/** Path patterns with confidence weights */
const PATH_PATTERNS: ReadonlyArray<{ pattern: RegExp; weight: number; name: string }> = [
  { pattern: /__generated__/i, weight: 0.8, name: '__generated__' },
  { pattern: /\/generated\//i, weight: 0.7, name: '/generated/' },
  { pattern: /\.generated\./i, weight: 0.7, name: '.generated.' },
  { pattern: /\/dist\//i, weight: 0.6, name: '/dist/' },
  { pattern: /\/build\//i, weight: 0.55, name: '/build/' },
  { pattern: /\.d\.ts$/i, weight: 0.5, name: '.d.ts' },
  { pattern: /\.min\.(js|css)$/i, weight: 0.9, name: '.min.js/css' },
  { pattern: /\.bundle\./i, weight: 0.7, name: '.bundle.' },
  { pattern: /node_modules/i, weight: 0.95, name: 'node_modules' },
];

// ============================================================================
// LRU CACHE
// ============================================================================

interface CacheEntry {
  result: GeneratedFileResult;
  timestamp: number;
}

/** Simple LRU cache for detection results */
class LRUCache {
  private cache = new Map<string, CacheEntry>();
  private maxSize: number;

  constructor(maxSize: number) {
    this.maxSize = maxSize;
  }

  get(key: string): GeneratedFileResult | undefined {
    const entry = this.cache.get(key);
    if (!entry) return undefined;

    // Move to end (most recently used)
    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry.result;
  }

  set(key: string, result: GeneratedFileResult): void {
    // Remove oldest if at capacity
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      if (oldestKey) {
        this.cache.delete(oldestKey);
      }
    }

    this.cache.set(key, { result, timestamp: Date.now() });
  }

  has(key: string): boolean {
    return this.cache.has(key);
  }

  clear(): void {
    this.cache.clear();
  }

  get size(): number {
    return this.cache.size;
  }
}

/** Singleton cache instance */
const resultCache = new LRUCache(CACHE_MAX_SIZE);

// ============================================================================
// HEADER DETECTION
// ============================================================================

/**
 * Read first N lines of file content for header detection
 */
function getHeaderContent(content: string): string {
  const lines = content.split('\n');
  return lines.slice(0, HEADER_LINES_LIMIT).join('\n');
}

/**
 * Detect header markers in content
 */
function detectHeaderSignals(content: string): GeneratedSignal[] {
  const headerContent = getHeaderContent(content);
  const signals: GeneratedSignal[] = [];

  for (const { pattern, weight, name } of HEADER_PATTERNS) {
    const matched = pattern.test(headerContent);
    signals.push({
      type: 'header',
      pattern: name,
      weight,
      matched,
    });
  }

  return signals;
}

/**
 * Detect tool signatures in content
 */
function detectToolSignals(content: string): {
  signals: GeneratedSignal[];
  generator: string | null;
} {
  const headerContent = getHeaderContent(content);
  const signals: GeneratedSignal[] = [];
  let generator: string | null = null;

  for (const { pattern, weight, generator: gen } of TOOL_PATTERNS) {
    const matched = pattern.test(headerContent);
    signals.push({
      type: 'tool',
      pattern: gen,
      weight,
      matched,
    });

    // Track first matched generator
    if (matched && generator === null) {
      generator = gen;
    }
  }

  return { signals, generator };
}

// ============================================================================
// PATH DETECTION
// ============================================================================

/**
 * Detect path patterns in filepath
 */
function detectPathSignals(filepath: string): GeneratedSignal[] {
  const normalizedPath = filepath.replace(/\\/g, '/');
  const signals: GeneratedSignal[] = [];

  for (const { pattern, weight, name } of PATH_PATTERNS) {
    const matched = pattern.test(normalizedPath);
    signals.push({
      type: 'path',
      pattern: name,
      weight,
      matched,
    });
  }

  return signals;
}

// ============================================================================
// CONFIDENCE CALCULATION
// ============================================================================

/**
 * Calculate overall confidence from signals
 *
 * Uses weighted maximum approach - takes the highest matched signal weight
 * as the base confidence, with small additions from other matched signals.
 */
function calculateConfidence(signals: GeneratedSignal[]): number {
  const matchedSignals = signals.filter((s) => s.matched);

  if (matchedSignals.length === 0) {
    return 0;
  }

  // Sort by weight descending
  const sorted = [...matchedSignals].sort((a, b) => b.weight - a.weight);

  // Base confidence from highest weight
  const first = sorted[0];
  if (!first) {
    return 0;
  }

  let confidence = first.weight;

  // Add small bonus for additional signals (diminishing returns)
  for (let i = 1; i < sorted.length; i++) {
    const signal = sorted[i];
    if (signal) {
      const bonus = signal.weight * 0.1 * (1 / (i + 1));
      confidence = Math.min(1, confidence + bonus);
    }
  }

  return Math.round(confidence * 100) / 100;
}

// ============================================================================
// PUBLIC API
// ============================================================================

export interface DetectOptions {
  /** Cache the result for future lookups */
  cacheResult?: boolean;
}

/**
 * Detect if a file is generated based on filepath and optional content
 *
 * @param filepath - Path to the file
 * @param content - Optional file content (if not provided, only path-based detection)
 * @param options - Detection options
 * @returns Detection result with confidence and signals
 */
export function detectGeneratedFile(
  filepath: string,
  content?: string,
  options: DetectOptions = {},
): GeneratedFileResult {
  const { cacheResult = true } = options;
  const absolutePath = path.resolve(filepath);

  // Check cache first
  if (cacheResult) {
    const cached = resultCache.get(absolutePath);
    if (cached) {
      return cached;
    }
  }

  const signals: GeneratedSignal[] = [];
  let generator: string | null = null;

  // 1. Path-based signals (always available)
  const pathSignals = detectPathSignals(absolutePath);
  signals.push(...pathSignals);

  // 2. Content-based signals (if content provided)
  if (content) {
    const headerSignals = detectHeaderSignals(content);
    signals.push(...headerSignals);

    const toolResult = detectToolSignals(content);
    signals.push(...toolResult.signals);
    generator = toolResult.generator;
  }

  // 3. Calculate confidence
  const confidence = calculateConfidence(signals);

  // Build result object - only include generator if found
  const result: GeneratedFileResult = generator
    ? {
        isGenerated: confidence >= DEFAULT_THRESHOLD,
        confidence,
        signals,
        generator,
      }
    : {
        isGenerated: confidence >= DEFAULT_THRESHOLD,
        confidence,
        signals,
      };

  // Cache result if enabled
  if (cacheResult) {
    resultCache.set(absolutePath, result);
  }

  return result;
}

/**
 * Quick check if file is generated (path-only detection with optional content)
 *
 * @param filepath - Path to the file
 * @param threshold - Confidence threshold (default: 0.7)
 * @returns true if file appears to be generated
 */
export function isGeneratedFile(filepath: string, threshold = DEFAULT_THRESHOLD): boolean {
  const absolutePath = path.resolve(filepath);

  // Check cache first
  const cached = resultCache.get(absolutePath);
  if (cached) {
    return cached.confidence >= threshold;
  }

  // Path-only detection for quick check
  const pathSignals = detectPathSignals(absolutePath);
  const confidence = calculateConfidence(pathSignals);

  // If path-based detection is conclusive, return immediately
  if (confidence >= threshold) {
    return true;
  }

  // Try to read file content for deeper analysis
  try {
    const content = fs.readFileSync(absolutePath, 'utf-8');
    const result = detectGeneratedFile(absolutePath, content);
    return result.confidence >= threshold;
  } catch {
    // File not readable, use path-only result
    return false;
  }
}

/**
 * Detect generated file with content reading from disk
 *
 * @param filepath - Path to the file
 * @param options - Detection options
 * @returns Detection result
 */
export function detectGeneratedFileFromDisk(
  filepath: string,
  options: DetectOptions = {},
): GeneratedFileResult {
  try {
    const content = fs.readFileSync(filepath, 'utf-8');
    return detectGeneratedFile(filepath, content, options);
  } catch {
    // File not readable, use path-only detection
    return detectGeneratedFile(filepath, undefined, options);
  }
}

/**
 * Clear the detection cache
 */
export function clearGeneratedCache(): void {
  resultCache.clear();
}

/**
 * Get cache statistics
 */
export function getGeneratedCacheStats(): { size: number; maxSize: number } {
  return {
    size: resultCache.size,
    maxSize: CACHE_MAX_SIZE,
  };
}
