/**
 * SessionAdapter - Unified session management adapter
 *
 * Bridges legacy executor's ISessionManager interface with ADK's SQLiteSessionService.
 * Consolidates session management into a single system.
 *
 * @module @ralph/services/session-adapter
 */

import { randomUUID } from "node:crypto";
import { SQLiteSessionService } from "./sqlite-session";
import type { Session, Event } from "@google/adk";

// ============================================================================
// Legacy Interface (for backwards compatibility)
// ============================================================================

export interface CreateSessionConfig {
  project: string;
  projectPath: string;
  prdPath: string;
  totalTasks: number;
  config: Record<string, unknown>;
}

export interface CreateAttemptConfig {
  taskId: number;
  prdTaskId: string;
  attemptNumber: number;
  model: string;
  projectPath: string;
}

export interface CompleteAttemptData {
  success: boolean;
  inputTokens?: number;
  outputTokens?: number;
  costUsd?: number;
  filesModified?: string[];
  validationPassed?: boolean;
  validationOutput?: string;
  errorMessage?: string;
  errorStack?: string;
  projectPath: string;
}

export interface ISessionManager {
  createSession(config: CreateSessionConfig): string;
  updateCurrentTask(sessionId: string, taskId: string, projectPath?: string): void;
  incrementCompletedTasks(sessionId: string, projectPath?: string): void;
  incrementFailedTasks(sessionId: string, projectPath?: string): void;
  addTokensAndCost(sessionId: string, tokens: number, costUsd: number, projectPath?: string): void;
  pauseSession(sessionId: string, projectPath?: string): void;
  resumeSession(sessionId: string, projectPath?: string): void;
  completeSession(sessionId: string, projectPath?: string): void;
  failSession(sessionId: string, projectPath?: string): void;
  cancelSession(sessionId: string, projectPath?: string): void;
  createAttempt(config: CreateAttemptConfig): number;
  completeAttempt(attemptId: number, data: CompleteAttemptData): void;
}

// ============================================================================
// Session State Keys
// ============================================================================

const STATE_KEYS = {
  PROJECT: "project",
  PRD_PATH: "prdPath",
  TOTAL_TASKS: "totalTasks",
  COMPLETED_TASKS: "completedTasks",
  FAILED_TASKS: "failedTasks",
  SKIPPED_TASKS: "skippedTasks",
  CURRENT_TASK: "currentTask",
  STATUS: "status",
  TOTAL_TOKENS: "totalTokens",
  TOTAL_COST_USD: "totalCostUsd",
  CONFIG: "config",
  ATTEMPTS: "attempts",
} as const;

// ============================================================================
// Session Adapter
// ============================================================================

/**
 * Adapter that wraps SQLiteSessionService to implement ISessionManager
 *
 * Stores all session state in the ADK session state object.
 */
export class SessionAdapter implements ISessionManager {
  private services: Map<string, SQLiteSessionService> = new Map();
  private sessions: Map<string, Session> = new Map();
  private attemptCounter = 0;

  /**
   * Get or create SQLiteSessionService for a project
   */
  private getService(projectPath: string): SQLiteSessionService {
    let service = this.services.get(projectPath);
    if (!service) {
      const dbPath = `${projectPath}/.krolik/ralph-sessions.db`;
      service = new SQLiteSessionService(dbPath);
      this.services.set(projectPath, service);
    }
    return service;
  }

  /**
   * Get cached session
   */
  private getSession(sessionId: string): Session | undefined {
    return this.sessions.get(sessionId);
  }

  /**
   * Create a new session
   */
  createSession(config: CreateSessionConfig): string {
    const service = this.getService(config.projectPath);
    const sessionId = randomUUID();

    // Create session with initial state
    const session = {
      id: sessionId,
      appName: "ralph-loop",
      userId: config.project,
      state: {
        [STATE_KEYS.PROJECT]: config.project,
        [STATE_KEYS.PRD_PATH]: config.prdPath,
        [STATE_KEYS.TOTAL_TASKS]: config.totalTasks,
        [STATE_KEYS.COMPLETED_TASKS]: 0,
        [STATE_KEYS.FAILED_TASKS]: 0,
        [STATE_KEYS.SKIPPED_TASKS]: 0,
        [STATE_KEYS.STATUS]: "running",
        [STATE_KEYS.TOTAL_TOKENS]: 0,
        [STATE_KEYS.TOTAL_COST_USD]: 0,
        [STATE_KEYS.CONFIG]: config.config,
        [STATE_KEYS.ATTEMPTS]: [],
      },
      events: [],
      lastUpdateTime: Date.now(),
    } as Session;

    // Persist synchronously
    service.createSession({
      appName: session.appName,
      userId: session.userId,
      sessionId: session.id,
      state: session.state,
    }).catch(() => {});

    this.sessions.set(sessionId, session);
    return sessionId;
  }

  /**
   * Update current task
   */
  updateCurrentTask(sessionId: string, taskId: string, _projectPath?: string): void {
    const session = this.getSession(sessionId);
    if (session) {
      session.state[STATE_KEYS.CURRENT_TASK] = taskId;
      this.persistState(sessionId);
    }
  }

  /**
   * Increment completed tasks counter
   */
  incrementCompletedTasks(sessionId: string, _projectPath?: string): void {
    const session = this.getSession(sessionId);
    if (session) {
      const current = (session.state[STATE_KEYS.COMPLETED_TASKS] as number) ?? 0;
      session.state[STATE_KEYS.COMPLETED_TASKS] = current + 1;
      this.persistState(sessionId);
    }
  }

  /**
   * Increment failed tasks counter
   */
  incrementFailedTasks(sessionId: string, _projectPath?: string): void {
    const session = this.getSession(sessionId);
    if (session) {
      const current = (session.state[STATE_KEYS.FAILED_TASKS] as number) ?? 0;
      session.state[STATE_KEYS.FAILED_TASKS] = current + 1;
      this.persistState(sessionId);
    }
  }

  /**
   * Add tokens and cost
   */
  addTokensAndCost(sessionId: string, tokens: number, costUsd: number, _projectPath?: string): void {
    const session = this.getSession(sessionId);
    if (session) {
      const currentTokens = (session.state[STATE_KEYS.TOTAL_TOKENS] as number) ?? 0;
      const currentCost = (session.state[STATE_KEYS.TOTAL_COST_USD] as number) ?? 0;
      session.state[STATE_KEYS.TOTAL_TOKENS] = currentTokens + tokens;
      session.state[STATE_KEYS.TOTAL_COST_USD] = currentCost + costUsd;
      this.persistState(sessionId);
    }
  }

  /**
   * Pause session
   */
  pauseSession(sessionId: string, _projectPath?: string): void {
    const session = this.getSession(sessionId);
    if (session) {
      session.state[STATE_KEYS.STATUS] = "paused";
      this.persistState(sessionId);
    }
  }

  /**
   * Resume session
   */
  resumeSession(sessionId: string, _projectPath?: string): void {
    const session = this.getSession(sessionId);
    if (session) {
      session.state[STATE_KEYS.STATUS] = "running";
      this.persistState(sessionId);
    }
  }

  /**
   * Complete session
   */
  completeSession(sessionId: string, _projectPath?: string): void {
    const session = this.getSession(sessionId);
    if (session) {
      session.state[STATE_KEYS.STATUS] = "completed";
      this.persistState(sessionId);
    }
  }

  /**
   * Mark session as failed
   */
  failSession(sessionId: string, _projectPath?: string): void {
    const session = this.getSession(sessionId);
    if (session) {
      session.state[STATE_KEYS.STATUS] = "failed";
      this.persistState(sessionId);
    }
  }

  /**
   * Cancel session
   */
  cancelSession(sessionId: string, _projectPath?: string): void {
    const session = this.getSession(sessionId);
    if (session) {
      session.state[STATE_KEYS.STATUS] = "cancelled";
      this.persistState(sessionId);
    }
  }

  /**
   * Create an attempt record
   */
  createAttempt(config: CreateAttemptConfig): number {
    this.attemptCounter++;
    const attemptId = this.attemptCounter;

    // Store attempt in session state
    // (We find session by iterating - not ideal but works for adapter)
    for (const session of this.sessions.values()) {
      const attempts = (session.state[STATE_KEYS.ATTEMPTS] as unknown[]) ?? [];
      attempts.push({
        id: attemptId,
        taskId: config.taskId,
        prdTaskId: config.prdTaskId,
        attemptNumber: config.attemptNumber,
        model: config.model,
        startedAt: new Date().toISOString(),
        status: "running",
      });
      session.state[STATE_KEYS.ATTEMPTS] = attempts;
      break; // Only update the first session
    }

    return attemptId;
  }

  /**
   * Complete an attempt
   */
  completeAttempt(attemptId: number, data: CompleteAttemptData): void {
    // Find and update attempt in session state
    for (const session of this.sessions.values()) {
      const attempts = (session.state[STATE_KEYS.ATTEMPTS] as Record<string, unknown>[]) ?? [];
      const attempt = attempts.find((a) => a.id === attemptId);
      if (attempt) {
        attempt.status = data.success ? "success" : "failed";
        attempt.completedAt = new Date().toISOString();
        attempt.inputTokens = data.inputTokens;
        attempt.outputTokens = data.outputTokens;
        attempt.costUsd = data.costUsd;
        attempt.filesModified = data.filesModified;
        attempt.validationPassed = data.validationPassed;
        attempt.validationOutput = data.validationOutput;
        attempt.errorMessage = data.errorMessage;
        break;
      }
    }
  }

  /**
   * Persist session state to database
   */
  private persistState(sessionId: string): void {
    const session = this.getSession(sessionId);
    if (!session) return;

    // Get project path from state
    const projectPath = session.state[STATE_KEYS.PROJECT] as string;
    if (!projectPath) return;

    // We need to find the service - use project path from state
    // Note: This is a simplification - in production you'd store projectPath in session
    for (const [path, service] of this.services) {
      if (path.includes(projectPath) || projectPath.includes(path.split("/").pop() ?? "")) {
        // Append event with state delta
        const event: Event = {
          id: randomUUID(),
          invocationId: sessionId,
          timestamp: Date.now(),
          actions: {
            stateDelta: session.state,
            artifactDelta: {},
            requestedAuthConfigs: {},
            requestedToolConfirmations: {},
          },
        };

        service.appendEvent({
          session,
          event,
        }).catch(() => {});
        break;
      }
    }
  }

  /**
   * Close all database connections
   */
  close(): void {
    for (const service of this.services.values()) {
      service.close();
    }
    this.services.clear();
    this.sessions.clear();
  }
}

// ============================================================================
// Singleton
// ============================================================================

let defaultAdapter: SessionAdapter | null = null;

/**
 * Get default session adapter instance
 */
export function getSessionAdapter(): ISessionManager {
  if (!defaultAdapter) {
    defaultAdapter = new SessionAdapter();
  }
  return defaultAdapter;
}

/**
 * Create a mock session manager for testing
 */
export function createMockSessionManager(): ISessionManager {
  return {
    createSession: () => "mock-session-id",
    updateCurrentTask: () => {},
    incrementCompletedTasks: () => {},
    incrementFailedTasks: () => {},
    addTokensAndCost: () => {},
    pauseSession: () => {},
    resumeSession: () => {},
    completeSession: () => {},
    failSession: () => {},
    cancelSession: () => {},
    createAttempt: () => 1,
    completeAttempt: () => {},
  };
}
